/* automatically generated by rust-bindgen */

pub const __GNUC_VA_LIST : u32 = 1 ; pub const _ERRNO_H : u32 = 1 ; pub const _FEATURES_H : u32 = 1 ; pub const _DEFAULT_SOURCE : u32 = 1 ; pub const __USE_ISOC11 : u32 = 1 ; pub const __USE_ISOC99 : u32 = 1 ; pub const __USE_ISOC95 : u32 = 1 ; pub const __USE_POSIX_IMPLICITLY : u32 = 1 ; pub const _POSIX_SOURCE : u32 = 1 ; pub const _POSIX_C_SOURCE : u32 = 200809 ; pub const __USE_POSIX : u32 = 1 ; pub const __USE_POSIX2 : u32 = 1 ; pub const __USE_POSIX199309 : u32 = 1 ; pub const __USE_POSIX199506 : u32 = 1 ; pub const __USE_XOPEN2K : u32 = 1 ; pub const __USE_XOPEN2K8 : u32 = 1 ; pub const _ATFILE_SOURCE : u32 = 1 ; pub const __USE_MISC : u32 = 1 ; pub const __USE_ATFILE : u32 = 1 ; pub const __USE_FORTIFY_LEVEL : u32 = 0 ; pub const _STDC_PREDEF_H : u32 = 1 ; pub const __STDC_IEC_559__ : u32 = 1 ; pub const __STDC_IEC_559_COMPLEX__ : u32 = 1 ; pub const __STDC_ISO_10646__ : u32 = 201605 ; pub const __STDC_NO_THREADS__ : u32 = 1 ; pub const __GNU_LIBRARY__ : u32 = 6 ; pub const __GLIBC__ : u32 = 2 ; pub const __GLIBC_MINOR__ : u32 = 24 ; pub const _SYS_CDEFS_H : u32 = 1 ; pub const __WORDSIZE : u32 = 64 ; pub const __WORDSIZE_TIME64_COMPAT32 : u32 = 1 ; pub const __SYSCALL_WORDSIZE : u32 = 64 ; pub const EPERM : u32 = 1 ; pub const ENOENT : u32 = 2 ; pub const ESRCH : u32 = 3 ; pub const EINTR : u32 = 4 ; pub const EIO : u32 = 5 ; pub const ENXIO : u32 = 6 ; pub const E2BIG : u32 = 7 ; pub const ENOEXEC : u32 = 8 ; pub const EBADF : u32 = 9 ; pub const ECHILD : u32 = 10 ; pub const EAGAIN : u32 = 11 ; pub const ENOMEM : u32 = 12 ; pub const EACCES : u32 = 13 ; pub const EFAULT : u32 = 14 ; pub const ENOTBLK : u32 = 15 ; pub const EBUSY : u32 = 16 ; pub const EEXIST : u32 = 17 ; pub const EXDEV : u32 = 18 ; pub const ENODEV : u32 = 19 ; pub const ENOTDIR : u32 = 20 ; pub const EISDIR : u32 = 21 ; pub const EINVAL : u32 = 22 ; pub const ENFILE : u32 = 23 ; pub const EMFILE : u32 = 24 ; pub const ENOTTY : u32 = 25 ; pub const ETXTBSY : u32 = 26 ; pub const EFBIG : u32 = 27 ; pub const ENOSPC : u32 = 28 ; pub const ESPIPE : u32 = 29 ; pub const EROFS : u32 = 30 ; pub const EMLINK : u32 = 31 ; pub const EPIPE : u32 = 32 ; pub const EDOM : u32 = 33 ; pub const ERANGE : u32 = 34 ; pub const EDEADLK : u32 = 35 ; pub const ENAMETOOLONG : u32 = 36 ; pub const ENOLCK : u32 = 37 ; pub const ENOSYS : u32 = 38 ; pub const ENOTEMPTY : u32 = 39 ; pub const ELOOP : u32 = 40 ; pub const EWOULDBLOCK : u32 = 11 ; pub const ENOMSG : u32 = 42 ; pub const EIDRM : u32 = 43 ; pub const ECHRNG : u32 = 44 ; pub const EL2NSYNC : u32 = 45 ; pub const EL3HLT : u32 = 46 ; pub const EL3RST : u32 = 47 ; pub const ELNRNG : u32 = 48 ; pub const EUNATCH : u32 = 49 ; pub const ENOCSI : u32 = 50 ; pub const EL2HLT : u32 = 51 ; pub const EBADE : u32 = 52 ; pub const EBADR : u32 = 53 ; pub const EXFULL : u32 = 54 ; pub const ENOANO : u32 = 55 ; pub const EBADRQC : u32 = 56 ; pub const EBADSLT : u32 = 57 ; pub const EDEADLOCK : u32 = 35 ; pub const EBFONT : u32 = 59 ; pub const ENOSTR : u32 = 60 ; pub const ENODATA : u32 = 61 ; pub const ETIME : u32 = 62 ; pub const ENOSR : u32 = 63 ; pub const ENONET : u32 = 64 ; pub const ENOPKG : u32 = 65 ; pub const EREMOTE : u32 = 66 ; pub const ENOLINK : u32 = 67 ; pub const EADV : u32 = 68 ; pub const ESRMNT : u32 = 69 ; pub const ECOMM : u32 = 70 ; pub const EPROTO : u32 = 71 ; pub const EMULTIHOP : u32 = 72 ; pub const EDOTDOT : u32 = 73 ; pub const EBADMSG : u32 = 74 ; pub const EOVERFLOW : u32 = 75 ; pub const ENOTUNIQ : u32 = 76 ; pub const EBADFD : u32 = 77 ; pub const EREMCHG : u32 = 78 ; pub const ELIBACC : u32 = 79 ; pub const ELIBBAD : u32 = 80 ; pub const ELIBSCN : u32 = 81 ; pub const ELIBMAX : u32 = 82 ; pub const ELIBEXEC : u32 = 83 ; pub const EILSEQ : u32 = 84 ; pub const ERESTART : u32 = 85 ; pub const ESTRPIPE : u32 = 86 ; pub const EUSERS : u32 = 87 ; pub const ENOTSOCK : u32 = 88 ; pub const EDESTADDRREQ : u32 = 89 ; pub const EMSGSIZE : u32 = 90 ; pub const EPROTOTYPE : u32 = 91 ; pub const ENOPROTOOPT : u32 = 92 ; pub const EPROTONOSUPPORT : u32 = 93 ; pub const ESOCKTNOSUPPORT : u32 = 94 ; pub const EOPNOTSUPP : u32 = 95 ; pub const EPFNOSUPPORT : u32 = 96 ; pub const EAFNOSUPPORT : u32 = 97 ; pub const EADDRINUSE : u32 = 98 ; pub const EADDRNOTAVAIL : u32 = 99 ; pub const ENETDOWN : u32 = 100 ; pub const ENETUNREACH : u32 = 101 ; pub const ENETRESET : u32 = 102 ; pub const ECONNABORTED : u32 = 103 ; pub const ECONNRESET : u32 = 104 ; pub const ENOBUFS : u32 = 105 ; pub const EISCONN : u32 = 106 ; pub const ENOTCONN : u32 = 107 ; pub const ESHUTDOWN : u32 = 108 ; pub const ETOOMANYREFS : u32 = 109 ; pub const ETIMEDOUT : u32 = 110 ; pub const ECONNREFUSED : u32 = 111 ; pub const EHOSTDOWN : u32 = 112 ; pub const EHOSTUNREACH : u32 = 113 ; pub const EALREADY : u32 = 114 ; pub const EINPROGRESS : u32 = 115 ; pub const ESTALE : u32 = 116 ; pub const EUCLEAN : u32 = 117 ; pub const ENOTNAM : u32 = 118 ; pub const ENAVAIL : u32 = 119 ; pub const EISNAM : u32 = 120 ; pub const EREMOTEIO : u32 = 121 ; pub const EDQUOT : u32 = 122 ; pub const ENOMEDIUM : u32 = 123 ; pub const EMEDIUMTYPE : u32 = 124 ; pub const ECANCELED : u32 = 125 ; pub const ENOKEY : u32 = 126 ; pub const EKEYEXPIRED : u32 = 127 ; pub const EKEYREVOKED : u32 = 128 ; pub const EKEYREJECTED : u32 = 129 ; pub const EOWNERDEAD : u32 = 130 ; pub const ENOTRECOVERABLE : u32 = 131 ; pub const ERFKILL : u32 = 132 ; pub const EHWPOISON : u32 = 133 ; pub const ENOTSUP : u32 = 95 ; pub const _STRING_H : u32 = 1 ; pub const _XLOCALE_H : u32 = 1 ; pub const _STDINT_H : u32 = 1 ; pub const _BITS_WCHAR_H : u32 = 1 ; pub const INT8_MIN : i32 = -128 ; pub const INT16_MIN : i32 = -32768 ; pub const INT32_MIN : i32 = -2147483648 ; pub const INT8_MAX : u32 = 127 ; pub const INT16_MAX : u32 = 32767 ; pub const INT32_MAX : u32 = 2147483647 ; pub const UINT8_MAX : u32 = 255 ; pub const UINT16_MAX : u32 = 65535 ; pub const UINT32_MAX : u32 = 4294967295 ; pub const INT_LEAST8_MIN : i32 = -128 ; pub const INT_LEAST16_MIN : i32 = -32768 ; pub const INT_LEAST32_MIN : i32 = -2147483648 ; pub const INT_LEAST8_MAX : u32 = 127 ; pub const INT_LEAST16_MAX : u32 = 32767 ; pub const INT_LEAST32_MAX : u32 = 2147483647 ; pub const UINT_LEAST8_MAX : u32 = 255 ; pub const UINT_LEAST16_MAX : u32 = 65535 ; pub const UINT_LEAST32_MAX : u32 = 4294967295 ; pub const INT_FAST8_MIN : i32 = -128 ; pub const INT_FAST16_MIN : i64 = -9223372036854775808 ; pub const INT_FAST32_MIN : i64 = -9223372036854775808 ; pub const INT_FAST8_MAX : u32 = 127 ; pub const INT_FAST16_MAX : u64 = 9223372036854775807 ; pub const INT_FAST32_MAX : u64 = 9223372036854775807 ; pub const UINT_FAST8_MAX : u32 = 255 ; pub const UINT_FAST16_MAX : i32 = -1 ; pub const UINT_FAST32_MAX : i32 = -1 ; pub const INTPTR_MIN : i64 = -9223372036854775808 ; pub const INTPTR_MAX : u64 = 9223372036854775807 ; pub const UINTPTR_MAX : i32 = -1 ; pub const PTRDIFF_MIN : i64 = -9223372036854775808 ; pub const PTRDIFF_MAX : u64 = 9223372036854775807 ; pub const SIG_ATOMIC_MIN : i32 = -2147483648 ; pub const SIG_ATOMIC_MAX : u32 = 2147483647 ; pub const SIZE_MAX : i32 = -1 ; pub const WINT_MIN : u32 = 0 ; pub const WINT_MAX : u32 = 4294967295 ; pub const true_ : u32 = 1 ; pub const false_ : u32 = 0 ; pub const __bool_true_false_are_defined : u32 = 1 ; pub const _STDIO_H : u32 = 1 ; pub const _BITS_TYPES_H : u32 = 1 ; pub const _BITS_TYPESIZES_H : u32 = 1 ; pub const __OFF_T_MATCHES_OFF64_T : u32 = 1 ; pub const __INO_T_MATCHES_INO64_T : u32 = 1 ; pub const __FD_SETSIZE : u32 = 1024 ; pub const __FILE_defined : u32 = 1 ; pub const ____FILE_defined : u32 = 1 ; pub const _G_config_h : u32 = 1 ; pub const ____mbstate_t_defined : u32 = 1 ; pub const _G_HAVE_MMAP : u32 = 1 ; pub const _G_HAVE_MREMAP : u32 = 1 ; pub const _G_IO_IO_FILE_VERSION : u32 = 131073 ; pub const _G_BUFSIZ : u32 = 8192 ; pub const _IO_BUFSIZ : u32 = 8192 ; pub const _IO_UNIFIED_JUMPTABLES : u32 = 1 ; pub const EOF : i32 = -1 ; pub const _IOS_INPUT : u32 = 1 ; pub const _IOS_OUTPUT : u32 = 2 ; pub const _IOS_ATEND : u32 = 4 ; pub const _IOS_APPEND : u32 = 8 ; pub const _IOS_TRUNC : u32 = 16 ; pub const _IOS_NOCREATE : u32 = 32 ; pub const _IOS_NOREPLACE : u32 = 64 ; pub const _IOS_BIN : u32 = 128 ; pub const _IO_MAGIC : u32 = 4222418944 ; pub const _OLD_STDIO_MAGIC : u32 = 4206624768 ; pub const _IO_MAGIC_MASK : u32 = 4294901760 ; pub const _IO_USER_BUF : u32 = 1 ; pub const _IO_UNBUFFERED : u32 = 2 ; pub const _IO_NO_READS : u32 = 4 ; pub const _IO_NO_WRITES : u32 = 8 ; pub const _IO_EOF_SEEN : u32 = 16 ; pub const _IO_ERR_SEEN : u32 = 32 ; pub const _IO_DELETE_DONT_CLOSE : u32 = 64 ; pub const _IO_LINKED : u32 = 128 ; pub const _IO_IN_BACKUP : u32 = 256 ; pub const _IO_LINE_BUF : u32 = 512 ; pub const _IO_TIED_PUT_GET : u32 = 1024 ; pub const _IO_CURRENTLY_PUTTING : u32 = 2048 ; pub const _IO_IS_APPENDING : u32 = 4096 ; pub const _IO_IS_FILEBUF : u32 = 8192 ; pub const _IO_BAD_SEEN : u32 = 16384 ; pub const _IO_USER_LOCK : u32 = 32768 ; pub const _IO_FLAGS2_MMAP : u32 = 1 ; pub const _IO_FLAGS2_NOTCANCEL : u32 = 2 ; pub const _IO_FLAGS2_USER_WBUF : u32 = 8 ; pub const _IO_SKIPWS : u32 = 1 ; pub const _IO_LEFT : u32 = 2 ; pub const _IO_RIGHT : u32 = 4 ; pub const _IO_INTERNAL : u32 = 8 ; pub const _IO_DEC : u32 = 16 ; pub const _IO_OCT : u32 = 32 ; pub const _IO_HEX : u32 = 64 ; pub const _IO_SHOWBASE : u32 = 128 ; pub const _IO_SHOWPOINT : u32 = 256 ; pub const _IO_UPPERCASE : u32 = 512 ; pub const _IO_SHOWPOS : u32 = 1024 ; pub const _IO_SCIENTIFIC : u32 = 2048 ; pub const _IO_FIXED : u32 = 4096 ; pub const _IO_UNITBUF : u32 = 8192 ; pub const _IO_STDIO : u32 = 16384 ; pub const _IO_DONT_CLOSE : u32 = 32768 ; pub const _IO_BOOLALPHA : u32 = 65536 ; pub const _IOFBF : u32 = 0 ; pub const _IOLBF : u32 = 1 ; pub const _IONBF : u32 = 2 ; pub const BUFSIZ : u32 = 8192 ; pub const SEEK_SET : u32 = 0 ; pub const SEEK_CUR : u32 = 1 ; pub const SEEK_END : u32 = 2 ; pub const P_tmpdir : & 'static [ u8 ; 5usize ] = b"/tmp\0" ; pub const L_tmpnam : u32 = 20 ; pub const TMP_MAX : u32 = 238328 ; pub const FILENAME_MAX : u32 = 4096 ; pub const L_ctermid : u32 = 9 ; pub const FOPEN_MAX : u32 = 16 ; pub const _SYS_TYPES_H : u32 = 1 ; pub const __clock_t_defined : u32 = 1 ; pub const __time_t_defined : u32 = 1 ; pub const __clockid_t_defined : u32 = 1 ; pub const __timer_t_defined : u32 = 1 ; pub const __BIT_TYPES_DEFINED__ : u32 = 1 ; pub const _ENDIAN_H : u32 = 1 ; pub const __LITTLE_ENDIAN : u32 = 1234 ; pub const __BIG_ENDIAN : u32 = 4321 ; pub const __PDP_ENDIAN : u32 = 3412 ; pub const __BYTE_ORDER : u32 = 1234 ; pub const __FLOAT_WORD_ORDER : u32 = 1234 ; pub const LITTLE_ENDIAN : u32 = 1234 ; pub const BIG_ENDIAN : u32 = 4321 ; pub const PDP_ENDIAN : u32 = 3412 ; pub const BYTE_ORDER : u32 = 1234 ; pub const _BITS_BYTESWAP_H : u32 = 1 ; pub const _SYS_SELECT_H : u32 = 1 ; pub const __FD_ZERO_STOS : & 'static [ u8 ; 6usize ] = b"stosq\0" ; pub const _SIGSET_H_types : u32 = 1 ; pub const __timespec_defined : u32 = 1 ; pub const _STRUCT_TIMEVAL : u32 = 1 ; pub const FD_SETSIZE : u32 = 1024 ; pub const _SYS_SYSMACROS_H : u32 = 1 ; pub const _BITS_PTHREADTYPES_H : u32 = 1 ; pub const __SIZEOF_PTHREAD_ATTR_T : u32 = 56 ; pub const __SIZEOF_PTHREAD_MUTEX_T : u32 = 40 ; pub const __SIZEOF_PTHREAD_MUTEXATTR_T : u32 = 4 ; pub const __SIZEOF_PTHREAD_COND_T : u32 = 48 ; pub const __SIZEOF_PTHREAD_CONDATTR_T : u32 = 4 ; pub const __SIZEOF_PTHREAD_RWLOCK_T : u32 = 56 ; pub const __SIZEOF_PTHREAD_RWLOCKATTR_T : u32 = 8 ; pub const __SIZEOF_PTHREAD_BARRIER_T : u32 = 32 ; pub const __SIZEOF_PTHREAD_BARRIERATTR_T : u32 = 4 ; pub const __have_pthread_attr_t : u32 = 1 ; pub const __PTHREAD_MUTEX_HAVE_PREV : u32 = 1 ; pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED : u32 = 1 ; pub const WINVER : u32 = 1281 ; pub const _LIBC_LIMITS_H_ : u32 = 1 ; pub const MB_LEN_MAX : u32 = 16 ; pub const _BITS_POSIX1_LIM_H : u32 = 1 ; pub const _POSIX_AIO_LISTIO_MAX : u32 = 2 ; pub const _POSIX_AIO_MAX : u32 = 1 ; pub const _POSIX_ARG_MAX : u32 = 4096 ; pub const _POSIX_CHILD_MAX : u32 = 25 ; pub const _POSIX_DELAYTIMER_MAX : u32 = 32 ; pub const _POSIX_HOST_NAME_MAX : u32 = 255 ; pub const _POSIX_LINK_MAX : u32 = 8 ; pub const _POSIX_LOGIN_NAME_MAX : u32 = 9 ; pub const _POSIX_MAX_CANON : u32 = 255 ; pub const _POSIX_MAX_INPUT : u32 = 255 ; pub const _POSIX_MQ_OPEN_MAX : u32 = 8 ; pub const _POSIX_MQ_PRIO_MAX : u32 = 32 ; pub const _POSIX_NAME_MAX : u32 = 14 ; pub const _POSIX_NGROUPS_MAX : u32 = 8 ; pub const _POSIX_OPEN_MAX : u32 = 20 ; pub const _POSIX_PATH_MAX : u32 = 256 ; pub const _POSIX_PIPE_BUF : u32 = 512 ; pub const _POSIX_RE_DUP_MAX : u32 = 255 ; pub const _POSIX_RTSIG_MAX : u32 = 8 ; pub const _POSIX_SEM_NSEMS_MAX : u32 = 256 ; pub const _POSIX_SEM_VALUE_MAX : u32 = 32767 ; pub const _POSIX_SIGQUEUE_MAX : u32 = 32 ; pub const _POSIX_SSIZE_MAX : u32 = 32767 ; pub const _POSIX_STREAM_MAX : u32 = 8 ; pub const _POSIX_SYMLINK_MAX : u32 = 255 ; pub const _POSIX_SYMLOOP_MAX : u32 = 8 ; pub const _POSIX_TIMER_MAX : u32 = 32 ; pub const _POSIX_TTY_NAME_MAX : u32 = 9 ; pub const _POSIX_TZNAME_MAX : u32 = 6 ; pub const _POSIX_CLOCKRES_MIN : u32 = 20000000 ; pub const NR_OPEN : u32 = 1024 ; pub const NGROUPS_MAX : u32 = 65536 ; pub const ARG_MAX : u32 = 131072 ; pub const LINK_MAX : u32 = 127 ; pub const MAX_CANON : u32 = 255 ; pub const MAX_INPUT : u32 = 255 ; pub const NAME_MAX : u32 = 255 ; pub const PATH_MAX : u32 = 4096 ; pub const PIPE_BUF : u32 = 4096 ; pub const XATTR_NAME_MAX : u32 = 255 ; pub const XATTR_SIZE_MAX : u32 = 65536 ; pub const XATTR_LIST_MAX : u32 = 65536 ; pub const RTSIG_MAX : u32 = 32 ; pub const _POSIX_THREAD_KEYS_MAX : u32 = 128 ; pub const PTHREAD_KEYS_MAX : u32 = 1024 ; pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS : u32 = 4 ; pub const PTHREAD_DESTRUCTOR_ITERATIONS : u32 = 4 ; pub const _POSIX_THREAD_THREADS_MAX : u32 = 64 ; pub const AIO_PRIO_DELTA_MAX : u32 = 20 ; pub const PTHREAD_STACK_MIN : u32 = 16384 ; pub const DELAYTIMER_MAX : u32 = 2147483647 ; pub const TTY_NAME_MAX : u32 = 32 ; pub const LOGIN_NAME_MAX : u32 = 256 ; pub const HOST_NAME_MAX : u32 = 64 ; pub const MQ_PRIO_MAX : u32 = 32768 ; pub const SEM_VALUE_MAX : u32 = 2147483647 ; pub const _BITS_POSIX2_LIM_H : u32 = 1 ; pub const _POSIX2_BC_BASE_MAX : u32 = 99 ; pub const _POSIX2_BC_DIM_MAX : u32 = 2048 ; pub const _POSIX2_BC_SCALE_MAX : u32 = 99 ; pub const _POSIX2_BC_STRING_MAX : u32 = 1000 ; pub const _POSIX2_COLL_WEIGHTS_MAX : u32 = 2 ; pub const _POSIX2_EXPR_NEST_MAX : u32 = 32 ; pub const _POSIX2_LINE_MAX : u32 = 2048 ; pub const _POSIX2_RE_DUP_MAX : u32 = 255 ; pub const _POSIX2_CHARCLASS_NAME_MAX : u32 = 14 ; pub const BC_BASE_MAX : u32 = 99 ; pub const BC_DIM_MAX : u32 = 2048 ; pub const BC_SCALE_MAX : u32 = 99 ; pub const BC_STRING_MAX : u32 = 1000 ; pub const COLL_WEIGHTS_MAX : u32 = 255 ; pub const EXPR_NEST_MAX : u32 = 32 ; pub const LINE_MAX : u32 = 2048 ; pub const CHARCLASS_NAME_MAX : u32 = 2048 ; pub const RE_DUP_MAX : u32 = 32767 ; pub const LUA_LIBEXT : & 'static [ u8 ; 4usize ] = b".so\0" ; pub const LUA_MULTILIB : & 'static [ u8 ; 4usize ] = b"lib\0" ; pub const LUA_LMULTILIB : & 'static [ u8 ; 4usize ] = b"lib\0" ; pub const LUA_LROOT : & 'static [ u8 ; 11usize ] = b"/usr/local\0" ; pub const LUA_LUADIR : & 'static [ u8 ; 10usize ] = b"/lua/5.1/\0" ; pub const LUA_LJDIR : & 'static [ u8 ; 21usize ] = b"/luajit-2.1.0-beta3/\0" ; pub const LUA_JROOT : & 'static [ u8 ; 11usize ] = b"/usr/local\0" ; pub const LUA_JPATH : & 'static [ u8 ; 43usize ] = b";/usr/local/share/luajit-2.1.0-beta3/?.lua\0" ; pub const LUA_LLDIR : & 'static [ u8 ; 26usize ] = b"/usr/local/share/lua/5.1/\0" ; pub const LUA_LCDIR : & 'static [ u8 ; 24usize ] = b"/usr/local/lib/lua/5.1/\0" ; pub const LUA_LLPATH : & 'static [ u8 ; 68usize ] = b";/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua\0" ; pub const LUA_LCPATH1 : & 'static [ u8 ; 29usize ] = b";/usr/local/lib/lua/5.1/?.so\0" ; pub const LUA_LCPATH2 : & 'static [ u8 ; 35usize ] = b";/usr/local/lib/lua/5.1/loadall.so\0" ; pub const LUA_PATH : & 'static [ u8 ; 9usize ] = b"LUA_PATH\0" ; pub const LUA_CPATH : & 'static [ u8 ; 10usize ] = b"LUA_CPATH\0" ; pub const LUA_INIT : & 'static [ u8 ; 9usize ] = b"LUA_INIT\0" ; pub const LUA_DIRSEP : & 'static [ u8 ; 2usize ] = b"/\0" ; pub const LUA_PATHSEP : & 'static [ u8 ; 2usize ] = b";\0" ; pub const LUA_PATH_MARK : & 'static [ u8 ; 2usize ] = b"?\0" ; pub const LUA_EXECDIR : & 'static [ u8 ; 2usize ] = b"!\0" ; pub const LUA_IGMARK : & 'static [ u8 ; 2usize ] = b"-\0" ; pub const LUA_PATH_CONFIG : & 'static [ u8 ; 11usize ] = b"/\n;\n?\n!\n-\n\0" ; pub const LUAI_MAXSTACK : u32 = 65500 ; pub const LUAI_MAXCSTACK : u32 = 8000 ; pub const LUAI_GCPAUSE : u32 = 200 ; pub const LUAI_GCMUL : u32 = 200 ; pub const LUA_MAXCAPTURES : u32 = 32 ; pub const LUA_IDSIZE : u32 = 60 ; pub const LUA_NUMBER_SCAN : & 'static [ u8 ; 4usize ] = b"%lf\0" ; pub const LUA_NUMBER_FMT : & 'static [ u8 ; 6usize ] = b"%.14g\0" ; pub const LUAI_MAXNUMBER2STR : u32 = 32 ; pub const LUA_INTFRMLEN : & 'static [ u8 ; 2usize ] = b"l\0" ; pub const LUA_VERSION : & 'static [ u8 ; 8usize ] = b"Lua 5.1\0" ; pub const LUA_RELEASE : & 'static [ u8 ; 10usize ] = b"Lua 5.1.4\0" ; pub const LUA_VERSION_NUM : u32 = 501 ; pub const LUA_COPYRIGHT : & 'static [ u8 ; 41usize ] = b"Copyright (C) 1994-2008 Lua.org, PUC-Rio\0" ; pub const LUA_AUTHORS : & 'static [ u8 ; 49usize ] = b"R. Ierusalimschy, L. H. de Figueiredo & W. Celes\0" ; pub const LUA_SIGNATURE : & 'static [ u8 ; 5usize ] = b"\x1BLua\0" ; pub const LUA_MULTRET : i32 = -1 ; pub const LUA_REGISTRYINDEX : i32 = -10000 ; pub const LUA_ENVIRONINDEX : i32 = -10001 ; pub const LUA_GLOBALSINDEX : i32 = -10002 ; pub const LUA_OK : u32 = 0 ; pub const LUA_YIELD : u32 = 1 ; pub const LUA_ERRRUN : u32 = 2 ; pub const LUA_ERRSYNTAX : u32 = 3 ; pub const LUA_ERRMEM : u32 = 4 ; pub const LUA_ERRERR : u32 = 5 ; pub const LUA_TNONE : i32 = -1 ; pub const LUA_TNIL : u32 = 0 ; pub const LUA_TBOOLEAN : u32 = 1 ; pub const LUA_TLIGHTUSERDATA : u32 = 2 ; pub const LUA_TNUMBER : u32 = 3 ; pub const LUA_TSTRING : u32 = 4 ; pub const LUA_TTABLE : u32 = 5 ; pub const LUA_TFUNCTION : u32 = 6 ; pub const LUA_TUSERDATA : u32 = 7 ; pub const LUA_TTHREAD : u32 = 8 ; pub const LUA_MINSTACK : u32 = 20 ; pub const LUA_GCSTOP : u32 = 0 ; pub const LUA_GCRESTART : u32 = 1 ; pub const LUA_GCCOLLECT : u32 = 2 ; pub const LUA_GCCOUNT : u32 = 3 ; pub const LUA_GCCOUNTB : u32 = 4 ; pub const LUA_GCSTEP : u32 = 5 ; pub const LUA_GCSETPAUSE : u32 = 6 ; pub const LUA_GCSETSTEPMUL : u32 = 7 ; pub const LUA_GCISRUNNING : u32 = 9 ; pub const LUA_HOOKCALL : u32 = 0 ; pub const LUA_HOOKRET : u32 = 1 ; pub const LUA_HOOKLINE : u32 = 2 ; pub const LUA_HOOKCOUNT : u32 = 3 ; pub const LUA_HOOKTAILRET : u32 = 4 ; pub const LUA_MASKCALL : u32 = 1 ; pub const LUA_MASKRET : u32 = 2 ; pub const LUA_MASKLINE : u32 = 4 ; pub const LUA_MASKCOUNT : u32 = 8 ; pub const PACKAGE_VERSION_MAJOR : u32 = 1 ; pub const PACKAGE_VERSION_MINOR : u32 = 10 ; pub const PACKAGE_VERSION_PATCH : u32 = 2 ; pub const PACKAGE_VERSION : & 'static [ u8 ; 21usize ] = b"1.10.2-98-gcb1bc1768\0" ; pub const SYSCONF_DIR : & 'static [ u8 ; 5usize ] = b"/etc\0" ; pub const INSTALL_PREFIX : & 'static [ u8 ; 5usize ] = b"/usr\0" ; pub const BUILD_TYPE : & 'static [ u8 ; 15usize ] = b"RelWithDebInfo\0" ; pub const BUILD_INFO : & 'static [ u8 ; 28usize ] = b"Linux-x86_64-RelWithDebInfo\0" ; pub const BUILD_OPTIONS : & 'static [ u8 ; 58usize ] = b"cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\0" ; pub const COMPILER_INFO : & 'static [ u8 ; 32usize ] = b"/usr/bin/cc /usr/lib/ccache/g++\0" ; pub const TARANTOOL_C_FLAGS : & 'static [ u8 ; 396usize ] = b"-g -O2 -fdebug-prefix-map=/build/tarantool-1.10.2.98=. -specs=/usr/share/dpkg/no-pie-compile.specs -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fexceptions -funwind-tables -fno-omit-frame-pointer -fno-stack-protector -fno-common -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-strict-aliasing -Wno-char-subscripts -Wno-format-truncation -fno-gnu89-inline -Wno-cast-function-type\0" ; pub const TARANTOOL_CXX_FLAGS : & 'static [ u8 ; 402usize ] = b"-g -O2 -fdebug-prefix-map=/build/tarantool-1.10.2.98=. -specs=/usr/share/dpkg/no-pie-compile.specs -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fexceptions -funwind-tables -fno-omit-frame-pointer -fno-stack-protector -fno-common -fopenmp -msse2 -std=c++11 -Wall -Wextra -Wno-strict-aliasing -Wno-char-subscripts -Wno-format-truncation -Wno-invalid-offsetof -Wno-cast-function-type\0" ; pub const MODULE_LIBDIR : & 'static [ u8 ; 36usize ] = b"/usr/lib/x86_64-linux-gnu/tarantool\0" ; pub const MODULE_LUADIR : & 'static [ u8 ; 21usize ] = b"/usr/share/tarantool\0" ; pub const MODULE_INCLUDEDIR : & 'static [ u8 ; 23usize ] = b"/usr/include/tarantool\0" ; pub const MODULE_LUAPATH : & 'static [ u8 ; 252usize ] = b"/usr/local/share/tarantool/?.lua;/usr/local/share/tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/init.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua\0" ; pub const MODULE_LIBPATH : & 'static [ u8 ; 230usize ] = b"/usr/local/lib/x86_64-linux-gnu/tarantool/?.so;/usr/lib/x86_64-linux-gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64-linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux-gnu/lua/5.1/?.so;/usr/local/lib/lua/5.1/?.so\0" ; pub const MODULE_LIBSUFFIX : & 'static [ u8 ; 4usize ] = b".so\0" ; pub const __alignas_is_defined : u32 = 1 ; pub const __alignof_is_defined : u32 = 1 ; pub type wchar_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct max_align_t { pub __clang_max_align_nonce1 : :: std :: os :: raw :: c_longlong , pub __bindgen_padding_0 : u64 , pub __clang_max_align_nonce2 : f64 , } # [ test ] fn bindgen_test_layout_max_align_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < max_align_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( max_align_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < max_align_t > ( ) ) ) . __clang_max_align_nonce1 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( max_align_t ) , "::" , stringify ! ( __clang_max_align_nonce1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < max_align_t > ( ) ) ) . __clang_max_align_nonce2 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( max_align_t ) , "::" , stringify ! ( __clang_max_align_nonce2 ) ) ) ; } pub type va_list = __builtin_va_list ; pub type __gnuc_va_list = __builtin_va_list ; extern "C" { pub fn __errno_location ( ) -> * mut :: std :: os :: raw :: c_int ; } extern "C" { pub fn memcpy ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memmove ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memccpy ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memset ( __s : * mut :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memcmp ( __s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn memchr ( __s : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn strcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcat ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strncat ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strncmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcoll ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strxfrm ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_ulong ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_struct { pub __locales : [ * mut __locale_data ; 13usize ] , pub __ctype_b : * const :: std :: os :: raw :: c_ushort , pub __ctype_tolower : * const :: std :: os :: raw :: c_int , pub __ctype_toupper : * const :: std :: os :: raw :: c_int , pub __names : [ * const :: std :: os :: raw :: c_char ; 13usize ] , } # [ test ] fn bindgen_test_layout___locale_struct ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __locale_struct > ( ) , 232usize , concat ! ( "Size of: " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __locale_struct > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __locales as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __locales ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_b as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_b ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_tolower as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_tolower ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_toupper as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_toupper ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __names as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __names ) ) ) ; } pub type __locale_t = * mut __locale_struct ; pub type locale_t = __locale_t ; extern "C" { pub fn strcoll_l ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __l : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strxfrm_l ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , __l : __locale_t ) -> usize ; } extern "C" { pub fn strdup ( __s : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strndup ( __string : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strchr ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strrchr ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcspn ( __s : * const :: std :: os :: raw :: c_char , __reject : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strspn ( __s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strpbrk ( __s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strstr ( __haystack : * const :: std :: os :: raw :: c_char , __needle : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strtok ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __strtok_r ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strtok_r ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strlen ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strnlen ( __string : * const :: std :: os :: raw :: c_char , __maxlen : usize ) -> usize ; } extern "C" { pub fn strerror ( __errnum : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}__xpg_strerror_r" ] pub fn strerror_r ( __errnum : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strerror_l ( __errnum : :: std :: os :: raw :: c_int , __l : __locale_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __bzero ( __s : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { pub fn bcopy ( __src : * const :: std :: os :: raw :: c_void , __dest : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { pub fn bzero ( __s : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { pub fn bcmp ( __s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn index ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn rindex ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn ffs ( __i : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcasecmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strncasecmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strsep ( __stringp : * mut * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strsignal ( __sig : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __stpcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn stpcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __stpncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn stpncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_long ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_long ; pub type int_fast32_t = :: std :: os :: raw :: c_long ; pub type int_fast64_t = :: std :: os :: raw :: c_long ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast32_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulong ; pub type intmax_t = :: std :: os :: raw :: c_long ; pub type uintmax_t = :: std :: os :: raw :: c_ulong ; pub type __u_char = :: std :: os :: raw :: c_uchar ; pub type __u_short = :: std :: os :: raw :: c_ushort ; pub type __u_int = :: std :: os :: raw :: c_uint ; pub type __u_long = :: std :: os :: raw :: c_ulong ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __quad_t = :: std :: os :: raw :: c_long ; pub type __u_quad_t = :: std :: os :: raw :: c_ulong ; pub type __dev_t = :: std :: os :: raw :: c_ulong ; pub type __uid_t = :: std :: os :: raw :: c_uint ; pub type __gid_t = :: std :: os :: raw :: c_uint ; pub type __ino_t = :: std :: os :: raw :: c_ulong ; pub type __ino64_t = :: std :: os :: raw :: c_ulong ; pub type __mode_t = :: std :: os :: raw :: c_uint ; pub type __nlink_t = :: std :: os :: raw :: c_ulong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type __pid_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __fsid_t { pub __val : [ :: std :: os :: raw :: c_int ; 2usize ] , } # [ test ] fn bindgen_test_layout___fsid_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __fsid_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __fsid_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __fsid_t > ( ) ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __fsid_t ) , "::" , stringify ! ( __val ) ) ) ; } pub type __clock_t = :: std :: os :: raw :: c_long ; pub type __rlim_t = :: std :: os :: raw :: c_ulong ; pub type __rlim64_t = :: std :: os :: raw :: c_ulong ; pub type __id_t = :: std :: os :: raw :: c_uint ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __useconds_t = :: std :: os :: raw :: c_uint ; pub type __suseconds_t = :: std :: os :: raw :: c_long ; pub type __daddr_t = :: std :: os :: raw :: c_int ; pub type __key_t = :: std :: os :: raw :: c_int ; pub type __clockid_t = :: std :: os :: raw :: c_int ; pub type __timer_t = * mut :: std :: os :: raw :: c_void ; pub type __blksize_t = :: std :: os :: raw :: c_long ; pub type __blkcnt_t = :: std :: os :: raw :: c_long ; pub type __blkcnt64_t = :: std :: os :: raw :: c_long ; pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsword_t = :: std :: os :: raw :: c_long ; pub type __ssize_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong ; pub type __loff_t = __off64_t ; pub type __qaddr_t = * mut __quad_t ; pub type __caddr_t = * mut :: std :: os :: raw :: c_char ; pub type __intptr_t = :: std :: os :: raw :: c_long ; pub type __socklen_t = :: std :: os :: raw :: c_uint ; pub type FILE = _IO_FILE ; pub type __FILE = _IO_FILE ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __mbstate_t { pub __count : :: std :: os :: raw :: c_int , pub __value : __mbstate_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __mbstate_t__bindgen_ty_1 { pub __wch : :: std :: os :: raw :: c_uint , pub __wchb : [ :: std :: os :: raw :: c_char ; 4usize ] , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout___mbstate_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t__bindgen_ty_1 > ( ) ) ) . __wch as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t__bindgen_ty_1 > ( ) ) ) . __wchb as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb ) ) ) ; } # [ test ] fn bindgen_test_layout___mbstate_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t > ( ) ) ) . __count as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t > ( ) ) ) . __value as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __value ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos_t { pub __pos : __off_t , pub __state : __mbstate_t , } # [ test ] fn bindgen_test_layout__G_fpos_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos_t > ( ) ) ) . __pos as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos_t ) , "::" , stringify ! ( __pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos_t > ( ) ) ) . __state as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos_t ) , "::" , stringify ! ( __state ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos64_t { pub __pos : __off64_t , pub __state : __mbstate_t , } # [ test ] fn bindgen_test_layout__G_fpos64_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos64_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos64_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos64_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos64_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos64_t > ( ) ) ) . __pos as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos64_t ) , "::" , stringify ! ( __pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos64_t > ( ) ) ) . __state as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos64_t ) , "::" , stringify ! ( __state ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_jump_t { _unused : [ u8 ; 0 ] , } pub type _IO_lock_t = :: std :: os :: raw :: c_void ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_marker { pub _next : * mut _IO_marker , pub _sbuf : * mut _IO_FILE , pub _pos : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout__IO_marker ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_marker > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _IO_marker ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_marker > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_marker ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_marker > ( ) ) ) . _next as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_marker > ( ) ) ) . _sbuf as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _sbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_marker > ( ) ) ) . _pos as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _pos ) ) ) ; } pub const __codecvt_result___codecvt_ok : __codecvt_result = 0 ; pub const __codecvt_result___codecvt_partial : __codecvt_result = 1 ; pub const __codecvt_result___codecvt_error : __codecvt_result = 2 ; pub const __codecvt_result___codecvt_noconv : __codecvt_result = 3 ; pub type __codecvt_result = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE { pub _flags : :: std :: os :: raw :: c_int , pub _IO_read_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_read_end : * mut :: std :: os :: raw :: c_char , pub _IO_read_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_write_end : * mut :: std :: os :: raw :: c_char , pub _IO_buf_base : * mut :: std :: os :: raw :: c_char , pub _IO_buf_end : * mut :: std :: os :: raw :: c_char , pub _IO_save_base : * mut :: std :: os :: raw :: c_char , pub _IO_backup_base : * mut :: std :: os :: raw :: c_char , pub _IO_save_end : * mut :: std :: os :: raw :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : :: std :: os :: raw :: c_int , pub _flags2 : :: std :: os :: raw :: c_int , pub _old_offset : __off_t , pub _cur_column : :: std :: os :: raw :: c_ushort , pub _vtable_offset : :: std :: os :: raw :: c_schar , pub _shortbuf : [ :: std :: os :: raw :: c_char ; 1usize ] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub __pad1 : * mut :: std :: os :: raw :: c_void , pub __pad2 : * mut :: std :: os :: raw :: c_void , pub __pad3 : * mut :: std :: os :: raw :: c_void , pub __pad4 : * mut :: std :: os :: raw :: c_void , pub __pad5 : usize , pub _mode : :: std :: os :: raw :: c_int , pub _unused2 : [ :: std :: os :: raw :: c_char ; 20usize ] , } # [ test ] fn bindgen_test_layout__IO_FILE ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_FILE > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( _IO_FILE ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_FILE > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_FILE ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _flags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_read_ptr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_read_end as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_read_base as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_write_base as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_write_ptr as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_write_end as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_buf_base as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_buf_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_buf_end as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_buf_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_save_base as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_save_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_backup_base as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_backup_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_save_end as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_save_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _markers as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _markers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _chain as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _fileno as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _fileno ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _flags2 as * const _ as usize } , 116usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _flags2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _old_offset as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _old_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _cur_column as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _cur_column ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _vtable_offset as * const _ as usize } , 130usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _vtable_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _shortbuf as * const _ as usize } , 131usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _shortbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _lock as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _offset as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad1 as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad2 as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad3 as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad4 as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad5 as * const _ as usize } , 184usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _mode as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _unused2 as * const _ as usize } , 196usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _unused2 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE_plus { _unused : [ u8 ; 0 ] , } extern "C" { # [ link_name = "\u{1}_IO_2_1_stdin_" ] pub static mut _IO_2_1_stdin_ : _IO_FILE_plus ; } extern "C" { # [ link_name = "\u{1}_IO_2_1_stdout_" ] pub static mut _IO_2_1_stdout_ : _IO_FILE_plus ; } extern "C" { # [ link_name = "\u{1}_IO_2_1_stderr_" ] pub static mut _IO_2_1_stderr_ : _IO_FILE_plus ; } pub type __io_read_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __buf : * mut :: std :: os :: raw :: c_char , __nbytes : usize ) -> __ssize_t > ; pub type __io_write_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __buf : * const :: std :: os :: raw :: c_char , __n : usize ) -> __ssize_t > ; pub type __io_seek_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __pos : * mut __off64_t , __w : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > ; pub type __io_close_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" { pub fn __underflow ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __uflow ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __overflow ( arg1 : * mut _IO_FILE , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_getc ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_putc ( __c : :: std :: os :: raw :: c_int , __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_feof ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_ferror ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_peekc_locked ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_flockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { pub fn _IO_funlockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { pub fn _IO_ftrylockfile ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_vfscanf ( arg1 : * mut _IO_FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag , arg4 : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_vfprintf ( arg1 : * mut _IO_FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_padn ( arg1 : * mut _IO_FILE , arg2 : :: std :: os :: raw :: c_int , arg3 : __ssize_t ) -> __ssize_t ; } extern "C" { pub fn _IO_sgetn ( arg1 : * mut _IO_FILE , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : usize ) -> usize ; } extern "C" { pub fn _IO_seekoff ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : :: std :: os :: raw :: c_int , arg4 : :: std :: os :: raw :: c_int ) -> __off64_t ; } extern "C" { pub fn _IO_seekpos ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : :: std :: os :: raw :: c_int ) -> __off64_t ; } extern "C" { pub fn _IO_free_backup_area ( arg1 : * mut _IO_FILE ) ; } pub type off_t = __off_t ; pub type fpos_t = _G_fpos_t ; extern "C" { # [ link_name = "\u{1}stdin" ] pub static mut stdin : * mut _IO_FILE ; } extern "C" { # [ link_name = "\u{1}stdout" ] pub static mut stdout : * mut _IO_FILE ; } extern "C" { # [ link_name = "\u{1}stderr" ] pub static mut stderr : * mut _IO_FILE ; } extern "C" { pub fn remove ( __filename : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn rename ( __old : * const :: std :: os :: raw :: c_char , __new : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn renameat ( __oldfd : :: std :: os :: raw :: c_int , __old : * const :: std :: os :: raw :: c_char , __newfd : :: std :: os :: raw :: c_int , __new : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn tmpfile ( ) -> * mut FILE ; } extern "C" { pub fn tmpnam ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn tmpnam_r ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn tempnam ( __dir : * const :: std :: os :: raw :: c_char , __pfx : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn fclose ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fflush ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fflush_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fopen ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn freopen ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> * mut FILE ; } extern "C" { pub fn fdopen ( __fd : :: std :: os :: raw :: c_int , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn fmemopen ( __s : * mut :: std :: os :: raw :: c_void , __len : usize , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn open_memstream ( __bufloc : * mut * mut :: std :: os :: raw :: c_char , __sizeloc : * mut usize ) -> * mut FILE ; } extern "C" { pub fn setbuf ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn setvbuf ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __modes : :: std :: os :: raw :: c_int , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setbuffer ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __size : usize ) ; } extern "C" { pub fn setlinebuf ( __stream : * mut FILE ) ; } extern "C" { pub fn fprintf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn printf ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sprintf ( __s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vfprintf ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vprintf ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsprintf ( __s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn snprintf ( __s : * mut :: std :: os :: raw :: c_char , __maxlen : usize , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsnprintf ( __s : * mut :: std :: os :: raw :: c_char , __maxlen : usize , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vdprintf ( __fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn dprintf ( __fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fscanf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn scanf ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sscanf ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_fscanf" ] pub fn fscanf1 ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_scanf" ] pub fn scanf1 ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_sscanf" ] pub fn sscanf1 ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vfscanf ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vscanf ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsscanf ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vfscanf" ] pub fn vfscanf1 ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vscanf" ] pub fn vscanf1 ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vsscanf" ] pub fn vsscanf1 ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgetc ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getc ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getchar ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getc_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getchar_unlocked ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgetc_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fputc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putchar ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fputc_unlocked ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putc_unlocked ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putchar_unlocked ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getw ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putw ( __w : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgets ( __s : * mut :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __getdelim ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn getdelim ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn getline ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn fputs ( __s : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn puts ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ungetc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fread ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __s : * mut FILE ) -> usize ; } extern "C" { pub fn fread_unlocked ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite_unlocked ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fseek ( __stream : * mut FILE , __off : :: std :: os :: raw :: c_long , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftell ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn rewind ( __stream : * mut FILE ) ; } extern "C" { pub fn fseeko ( __stream : * mut FILE , __off : __off_t , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftello ( __stream : * mut FILE ) -> __off_t ; } extern "C" { pub fn fgetpos ( __stream : * mut FILE , __pos : * mut fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fsetpos ( __stream : * mut FILE , __pos : * const fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clearerr ( __stream : * mut FILE ) ; } extern "C" { pub fn feof ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ferror ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clearerr_unlocked ( __stream : * mut FILE ) ; } extern "C" { pub fn feof_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ferror_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn perror ( __s : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}sys_nerr" ] pub static mut sys_nerr : :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}sys_errlist" ] pub static mut sys_errlist : [ * const :: std :: os :: raw :: c_char ; 0usize ] ; } extern "C" { pub fn fileno ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fileno_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn popen ( __command : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn pclose ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ctermid ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn flockfile ( __stream : * mut FILE ) ; } extern "C" { pub fn ftrylockfile ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn funlockfile ( __stream : * mut FILE ) ; } pub type u_char = __u_char ; pub type u_short = __u_short ; pub type u_int = __u_int ; pub type u_long = __u_long ; pub type quad_t = __quad_t ; pub type u_quad_t = __u_quad_t ; pub type fsid_t = __fsid_t ; pub type loff_t = __loff_t ; pub type ino_t = __ino_t ; pub type dev_t = __dev_t ; pub type gid_t = __gid_t ; pub type mode_t = __mode_t ; pub type nlink_t = __nlink_t ; pub type uid_t = __uid_t ; pub type pid_t = __pid_t ; pub type id_t = __id_t ; pub type daddr_t = __daddr_t ; pub type caddr_t = __caddr_t ; pub type key_t = __key_t ; pub type clock_t = __clock_t ; pub type time_t = __time_t ; pub type clockid_t = __clockid_t ; pub type timer_t = __timer_t ; pub type ulong = :: std :: os :: raw :: c_ulong ; pub type ushort = :: std :: os :: raw :: c_ushort ; pub type uint = :: std :: os :: raw :: c_uint ; pub type u_int8_t = :: std :: os :: raw :: c_uchar ; pub type u_int16_t = :: std :: os :: raw :: c_ushort ; pub type u_int32_t = :: std :: os :: raw :: c_uint ; pub type u_int64_t = :: std :: os :: raw :: c_ulong ; pub type register_t = :: std :: os :: raw :: c_long ; pub type __sig_atomic_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __sigset_t { pub __val : [ :: std :: os :: raw :: c_ulong ; 16usize ] , } # [ test ] fn bindgen_test_layout___sigset_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sigset_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( __sigset_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sigset_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sigset_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __sigset_t > ( ) ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __sigset_t ) , "::" , stringify ! ( __val ) ) ) ; } pub type sigset_t = __sigset_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } # [ test ] fn bindgen_test_layout_timespec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timespec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timespec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timespec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timespec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timespec > ( ) ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timespec > ( ) ) ) . tv_nsec as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_nsec ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timeval { pub tv_sec : __time_t , pub tv_usec : __suseconds_t , } # [ test ] fn bindgen_test_layout_timeval ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timeval > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timeval ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timeval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timeval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timeval > ( ) ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timeval > ( ) ) ) . tv_usec as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_usec ) ) ) ; } pub type suseconds_t = __suseconds_t ; pub type __fd_mask = :: std :: os :: raw :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct fd_set { pub __fds_bits : [ __fd_mask ; 16usize ] , } # [ test ] fn bindgen_test_layout_fd_set ( ) { assert_eq ! ( :: std :: mem :: size_of :: < fd_set > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( fd_set ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < fd_set > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( fd_set ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < fd_set > ( ) ) ) . __fds_bits as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( fd_set ) , "::" , stringify ! ( __fds_bits ) ) ) ; } pub type fd_mask = __fd_mask ; extern "C" { pub fn select ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * mut timeval ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pselect ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * const timespec , __sigmask : * const __sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn gnu_dev_major ( __dev : :: std :: os :: raw :: c_ulonglong ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn gnu_dev_minor ( __dev : :: std :: os :: raw :: c_ulonglong ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn gnu_dev_makedev ( __major : :: std :: os :: raw :: c_uint , __minor : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_ulonglong ; } pub type blksize_t = __blksize_t ; pub type blkcnt_t = __blkcnt_t ; pub type fsblkcnt_t = __fsblkcnt_t ; pub type fsfilcnt_t = __fsfilcnt_t ; pub type pthread_t = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_attr_t { pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } # [ test ] fn bindgen_test_layout_pthread_attr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_attr_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_attr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_attr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_attr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } # [ test ] fn bindgen_test_layout___pthread_internal_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_internal_list > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_internal_list > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_internal_list > ( ) ) ) . __prev as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_internal_list > ( ) ) ) . __next as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __next ) ) ) ; } pub type __pthread_list_t = __pthread_internal_list ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutex_t { pub __data : pthread_mutex_t___pthread_mutex_s , pub __size : [ :: std :: os :: raw :: c_char ; 40usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 5usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_mutex_t___pthread_mutex_s { pub __lock : :: std :: os :: raw :: c_int , pub __count : :: std :: os :: raw :: c_uint , pub __owner : :: std :: os :: raw :: c_int , pub __nusers : :: std :: os :: raw :: c_uint , pub __kind : :: std :: os :: raw :: c_int , pub __spins : :: std :: os :: raw :: c_short , pub __elision : :: std :: os :: raw :: c_short , pub __list : __pthread_list_t , } # [ test ] fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t___pthread_mutex_s > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t___pthread_mutex_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __count as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __owner as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __owner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __nusers as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __nusers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __kind as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __kind ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __spins as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __spins ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __elision as * const _ as usize } , 22usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __elision ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __list as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __list ) ) ) ; } # [ test ] fn bindgen_test_layout_pthread_mutex_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutexattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_mutexattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutexattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutexattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_cond_t { pub __data : pthread_cond_t__bindgen_ty_1 , pub __size : [ :: std :: os :: raw :: c_char ; 48usize ] , pub __align : :: std :: os :: raw :: c_longlong , _bindgen_union_align : [ u64 ; 6usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_cond_t__bindgen_ty_1 { pub __lock : :: std :: os :: raw :: c_int , pub __futex : :: std :: os :: raw :: c_uint , pub __total_seq : :: std :: os :: raw :: c_ulonglong , pub __wakeup_seq : :: std :: os :: raw :: c_ulonglong , pub __woken_seq : :: std :: os :: raw :: c_ulonglong , pub __mutex : * mut :: std :: os :: raw :: c_void , pub __nwaiters : :: std :: os :: raw :: c_uint , pub __broadcast_seq : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t__bindgen_ty_1 > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __futex as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __total_seq as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __total_seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __wakeup_seq as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __wakeup_seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __woken_seq as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __woken_seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __mutex as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __nwaiters as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __nwaiters ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __broadcast_seq as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __broadcast_seq ) ) ) ; } # [ test ] fn bindgen_test_layout_pthread_cond_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_condattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_condattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_condattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_condattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __align ) ) ) ; } pub type pthread_key_t = :: std :: os :: raw :: c_uint ; pub type pthread_once_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlock_t { pub __data : pthread_rwlock_t__bindgen_ty_1 , pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_rwlock_t__bindgen_ty_1 { pub __lock : :: std :: os :: raw :: c_int , pub __nr_readers : :: std :: os :: raw :: c_uint , pub __readers_wakeup : :: std :: os :: raw :: c_uint , pub __writer_wakeup : :: std :: os :: raw :: c_uint , pub __nr_readers_queued : :: std :: os :: raw :: c_uint , pub __nr_writers_queued : :: std :: os :: raw :: c_uint , pub __writer : :: std :: os :: raw :: c_int , pub __shared : :: std :: os :: raw :: c_int , pub __rwelision : :: std :: os :: raw :: c_schar , pub __pad1 : [ :: std :: os :: raw :: c_uchar ; 7usize ] , pub __pad2 : :: std :: os :: raw :: c_ulong , pub __flags : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t__bindgen_ty_1 > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __nr_readers as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __nr_readers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __readers_wakeup as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __readers_wakeup ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __writer_wakeup as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __writer_wakeup ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __nr_readers_queued as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __nr_readers_queued ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __nr_writers_queued as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __nr_writers_queued ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __writer as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __writer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __shared as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __shared ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __rwelision as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __rwelision ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __pad1 as * const _ as usize } , 33usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __pad2 as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __flags as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __flags ) ) ) ; } # [ test ] fn bindgen_test_layout_pthread_rwlock_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlockattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 8usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_pthread_rwlockattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlockattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlockattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __align ) ) ) ; } pub type pthread_spinlock_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrier_t { pub __size : [ :: std :: os :: raw :: c_char ; 32usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_pthread_barrier_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrier_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrier_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrier_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrier_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrierattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_barrierattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrierattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrierattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct lua_State { _unused : [ u8 ; 0 ] , } pub type lua_CFunction = :: std :: option :: Option < unsafe extern "C" fn ( L : * mut lua_State ) -> :: std :: os :: raw :: c_int > ; pub type lua_Reader = :: std :: option :: Option < unsafe extern "C" fn ( L : * mut lua_State , ud : * mut :: std :: os :: raw :: c_void , sz : * mut usize ) -> * const :: std :: os :: raw :: c_char > ; pub type lua_Writer = :: std :: option :: Option < unsafe extern "C" fn ( L : * mut lua_State , p : * const :: std :: os :: raw :: c_void , sz : usize , ud : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; pub type lua_Alloc = :: std :: option :: Option < unsafe extern "C" fn ( ud : * mut :: std :: os :: raw :: c_void , ptr : * mut :: std :: os :: raw :: c_void , osize : usize , nsize : usize ) -> * mut :: std :: os :: raw :: c_void > ; pub type lua_Number = f64 ; pub type lua_Integer = isize ; extern "C" { pub fn lua_newstate ( f : lua_Alloc , ud : * mut :: std :: os :: raw :: c_void ) -> * mut lua_State ; } extern "C" { pub fn lua_close ( L : * mut lua_State ) ; } extern "C" { pub fn lua_newthread ( L : * mut lua_State ) -> * mut lua_State ; } extern "C" { pub fn lua_atpanic ( L : * mut lua_State , panicf : lua_CFunction ) -> lua_CFunction ; } extern "C" { pub fn lua_gettop ( L : * mut lua_State ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_settop ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_pushvalue ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_remove ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_insert ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_replace ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_checkstack ( L : * mut lua_State , sz : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_xmove ( from : * mut lua_State , to : * mut lua_State , n : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_isnumber ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_isstring ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_iscfunction ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_isuserdata ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_type ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_typename ( L : * mut lua_State , tp : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn lua_equal ( L : * mut lua_State , idx1 : :: std :: os :: raw :: c_int , idx2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_rawequal ( L : * mut lua_State , idx1 : :: std :: os :: raw :: c_int , idx2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_lessthan ( L : * mut lua_State , idx1 : :: std :: os :: raw :: c_int , idx2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_tonumber ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> lua_Number ; } extern "C" { pub fn lua_tointeger ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> lua_Integer ; } extern "C" { pub fn lua_toboolean ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_tolstring ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int , len : * mut usize ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn lua_hashstring ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> u32 ; } extern "C" { pub fn lua_objlen ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> usize ; } extern "C" { pub fn lua_tocfunction ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> lua_CFunction ; } extern "C" { pub fn lua_touserdata ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn lua_tothread ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> * mut lua_State ; } extern "C" { pub fn lua_topointer ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_void ; } extern "C" { pub fn lua_pushnil ( L : * mut lua_State ) ; } extern "C" { pub fn lua_pushnumber ( L : * mut lua_State , n : lua_Number ) ; } extern "C" { pub fn lua_pushinteger ( L : * mut lua_State , n : lua_Integer ) ; } extern "C" { pub fn lua_pushlstring ( L : * mut lua_State , s : * const :: std :: os :: raw :: c_char , l : usize ) ; } extern "C" { pub fn lua_pushstring ( L : * mut lua_State , s : * const :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn lua_pushvfstring ( L : * mut lua_State , fmt : * const :: std :: os :: raw :: c_char , argp : * mut __va_list_tag ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn lua_pushfstring ( L : * mut lua_State , fmt : * const :: std :: os :: raw :: c_char , ... ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn lua_pushcclosure ( L : * mut lua_State , fn_ : lua_CFunction , n : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_pushboolean ( L : * mut lua_State , b : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_pushlightuserdata ( L : * mut lua_State , p : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn lua_pushthread ( L : * mut lua_State ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_gettable ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_getfield ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int , k : * const :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn lua_rawget ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_rawgeti ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int , n : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_createtable ( L : * mut lua_State , narr : :: std :: os :: raw :: c_int , nrec : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_newuserdata ( L : * mut lua_State , sz : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn lua_getmetatable ( L : * mut lua_State , objindex : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_getfenv ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_settable ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_setfield ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int , k : * const :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn lua_rawset ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_rawseti ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int , n : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_setmetatable ( L : * mut lua_State , objindex : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_setfenv ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_call ( L : * mut lua_State , nargs : :: std :: os :: raw :: c_int , nresults : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_pcall ( L : * mut lua_State , nargs : :: std :: os :: raw :: c_int , nresults : :: std :: os :: raw :: c_int , errfunc : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_cpcall ( L : * mut lua_State , func : lua_CFunction , ud : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_load ( L : * mut lua_State , reader : lua_Reader , dt : * mut :: std :: os :: raw :: c_void , chunkname : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_dump ( L : * mut lua_State , writer : lua_Writer , data : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_yield ( L : * mut lua_State , nresults : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_resume ( L : * mut lua_State , narg : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_status ( L : * mut lua_State ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_gc ( L : * mut lua_State , what : :: std :: os :: raw :: c_int , data : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_error ( L : * mut lua_State ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_next ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_concat ( L : * mut lua_State , n : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_getallocf ( L : * mut lua_State , ud : * mut * mut :: std :: os :: raw :: c_void ) -> lua_Alloc ; } extern "C" { pub fn lua_setallocf ( L : * mut lua_State , f : lua_Alloc , ud : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn lua_hash ( str : * const :: std :: os :: raw :: c_char , len : u32 ) -> u32 ; } extern "C" { pub fn lua_setlevel ( from : * mut lua_State , to : * mut lua_State ) ; } pub type lua_Hook = :: std :: option :: Option < unsafe extern "C" fn ( L : * mut lua_State , ar : * mut lua_Debug ) > ; extern "C" { pub fn lua_getstack ( L : * mut lua_State , level : :: std :: os :: raw :: c_int , ar : * mut lua_Debug ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_getinfo ( L : * mut lua_State , what : * const :: std :: os :: raw :: c_char , ar : * mut lua_Debug ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_getlocal ( L : * mut lua_State , ar : * const lua_Debug , n : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn lua_setlocal ( L : * mut lua_State , ar : * const lua_Debug , n : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn lua_getupvalue ( L : * mut lua_State , funcindex : :: std :: os :: raw :: c_int , n : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn lua_setupvalue ( L : * mut lua_State , funcindex : :: std :: os :: raw :: c_int , n : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn lua_sethook ( L : * mut lua_State , func : lua_Hook , mask : :: std :: os :: raw :: c_int , count : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_gethook ( L : * mut lua_State ) -> lua_Hook ; } extern "C" { pub fn lua_gethookmask ( L : * mut lua_State ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_gethookcount ( L : * mut lua_State ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_upvalueid ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int , n : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn lua_upvaluejoin ( L : * mut lua_State , idx1 : :: std :: os :: raw :: c_int , n1 : :: std :: os :: raw :: c_int , idx2 : :: std :: os :: raw :: c_int , n2 : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_loadx ( L : * mut lua_State , reader : lua_Reader , dt : * mut :: std :: os :: raw :: c_void , chunkname : * const :: std :: os :: raw :: c_char , mode : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lua_version ( L : * mut lua_State ) -> * const lua_Number ; } extern "C" { pub fn lua_copy ( L : * mut lua_State , fromidx : :: std :: os :: raw :: c_int , toidx : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn lua_tonumberx ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int , isnum : * mut :: std :: os :: raw :: c_int ) -> lua_Number ; } extern "C" { pub fn lua_tointegerx ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int , isnum : * mut :: std :: os :: raw :: c_int ) -> lua_Integer ; } extern "C" { pub fn lua_isyieldable ( L : * mut lua_State ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct lua_Debug { pub event : :: std :: os :: raw :: c_int , pub name : * const :: std :: os :: raw :: c_char , pub namewhat : * const :: std :: os :: raw :: c_char , pub what : * const :: std :: os :: raw :: c_char , pub source : * const :: std :: os :: raw :: c_char , pub currentline : :: std :: os :: raw :: c_int , pub nups : :: std :: os :: raw :: c_int , pub linedefined : :: std :: os :: raw :: c_int , pub lastlinedefined : :: std :: os :: raw :: c_int , pub short_src : [ :: std :: os :: raw :: c_char ; 60usize ] , pub i_ci : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_lua_Debug ( ) { assert_eq ! ( :: std :: mem :: size_of :: < lua_Debug > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( lua_Debug ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < lua_Debug > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( lua_Debug ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lua_Debug > ( ) ) ) . event as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( lua_Debug ) , "::" , stringify ! ( event ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lua_Debug > ( ) ) ) . name as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( lua_Debug ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lua_Debug > ( ) ) ) . namewhat as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( lua_Debug ) , "::" , stringify ! ( namewhat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lua_Debug > ( ) ) ) . what as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( lua_Debug ) , "::" , stringify ! ( what ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lua_Debug > ( ) ) ) . source as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( lua_Debug ) , "::" , stringify ! ( source ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lua_Debug > ( ) ) ) . currentline as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( lua_Debug ) , "::" , stringify ! ( currentline ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lua_Debug > ( ) ) ) . nups as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( lua_Debug ) , "::" , stringify ! ( nups ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lua_Debug > ( ) ) ) . linedefined as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( lua_Debug ) , "::" , stringify ! ( linedefined ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lua_Debug > ( ) ) ) . lastlinedefined as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( lua_Debug ) , "::" , stringify ! ( lastlinedefined ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lua_Debug > ( ) ) ) . short_src as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( lua_Debug ) , "::" , stringify ! ( short_src ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lua_Debug > ( ) ) ) . i_ci as * const _ as usize } , 116usize , concat ! ( "Offset of field: " , stringify ! ( lua_Debug ) , "::" , stringify ! ( i_ci ) ) ) ; } pub const say_level_S_FATAL : say_level = 0 ; pub const say_level_S_SYSERROR : say_level = 1 ; pub const say_level_S_ERROR : say_level = 2 ; pub const say_level_S_CRIT : say_level = 3 ; pub const say_level_S_WARN : say_level = 4 ; pub const say_level_S_INFO : say_level = 5 ; pub const say_level_S_VERBOSE : say_level = 6 ; pub const say_level_S_DEBUG : say_level = 7 ; # [ doc = " Log levels" ] pub type say_level = u32 ; pub const say_format_SF_PLAIN : say_format = 0 ; pub const say_format_SF_JSON : say_format = 1 ; pub const say_format_say_format_MAX : say_format = 2 ; # [ doc = " Log formats" ] pub type say_format = u32 ; extern "C" { # [ link_name = "\u{1}log_level" ] pub static mut log_level : :: std :: os :: raw :: c_int ; } # [ doc = " \\endcond public */" ] pub type sayfunc_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int , arg2 : * const :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int , arg4 : * const :: std :: os :: raw :: c_char , arg5 : * const :: std :: os :: raw :: c_char , ... ) > ; extern "C" { # [ link_name = "\u{1}_say" ] pub static mut _say : sayfunc_t ; } # [ doc = " Fiber attributes container" ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct fiber_attr { _unused : [ u8 ; 0 ] , } extern "C" { # [ doc = " Create a new fiber attribute container and initialize it" ] # [ doc = " with default parameters." ] # [ doc = " Can be used for many fibers creation, corresponding fibers" ] # [ doc = " will not take ownership." ] pub fn fiber_attr_new ( ) -> * mut fiber_attr ; } extern "C" { # [ doc = " Delete the fiber_attr and free all allocated resources." ] # [ doc = " This is safe when fibers created with this attribute still exist." ] # [ doc = "" ] # [ doc = "\\param fiber_attr fiber attribute" ] pub fn fiber_attr_delete ( fiber_attr : * mut fiber_attr ) ; } extern "C" { # [ doc = " Set stack size for the fiber attribute." ] # [ doc = "" ] # [ doc = " \\param fiber_attribute fiber attribute container" ] # [ doc = " \\param stacksize stack size for new fibers" ] pub fn fiber_attr_setstacksize ( fiber_attr : * mut fiber_attr , stack_size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Get stack size from the fiber attribute." ] # [ doc = "" ] # [ doc = " \\param fiber_attribute fiber attribute container or NULL for default" ] # [ doc = " \\retval stack size" ] pub fn fiber_attr_getstacksize ( fiber_attr : * mut fiber_attr ) -> usize ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct fiber { _unused : [ u8 ; 0 ] , } # [ doc = " Fiber - contains information about fiber" ] pub type fiber_func = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int > ; extern "C" { # [ doc = " Return the current fiber" ] pub fn fiber_self ( ) -> * mut fiber ; } extern "C" { # [ doc = " Create a new fiber." ] # [ doc = "" ] # [ doc = " Takes a fiber from fiber cache, if it\'s not empty." ] # [ doc = " Can fail only if there is not enough memory for" ] # [ doc = " the fiber structure or fiber stack." ] # [ doc = "" ] # [ doc = " The created fiber automatically returns itself" ] # [ doc = " to the fiber cache when its \"main\" function" ] # [ doc = " completes." ] # [ doc = "" ] # [ doc = " \\param name       string with fiber name" ] # [ doc = " \\param fiber_func func for run inside fiber" ] # [ doc = "" ] # [ doc = " \\sa fiber_start" ] pub fn fiber_new ( name : * const :: std :: os :: raw :: c_char , f : fiber_func ) -> * mut fiber ; } extern "C" { # [ doc = " Create a new fiber with defined attributes." ] # [ doc = "" ] # [ doc = " Can fail only if there is not enough memory for" ] # [ doc = " the fiber structure or fiber stack." ] # [ doc = "" ] # [ doc = " The created fiber automatically returns itself" ] # [ doc = " to the fiber cache if has default stack size" ] # [ doc = " when its \"main\" function completes." ] # [ doc = "" ] # [ doc = " \\param name       string with fiber name" ] # [ doc = " \\param fiber_attr fiber attributes" ] # [ doc = " \\param fiber_func func for run inside fiber" ] # [ doc = "" ] # [ doc = " \\sa fiber_start" ] pub fn fiber_new_ex ( name : * const :: std :: os :: raw :: c_char , fiber_attr : * const fiber_attr , f : fiber_func ) -> * mut fiber ; } extern "C" { # [ doc = " Return control to another fiber and wait until it\'ll be woken." ] # [ doc = "" ] # [ doc = " \\sa fiber_wakeup" ] pub fn fiber_yield ( ) ; } extern "C" { # [ doc = " Start execution of created fiber." ] # [ doc = "" ] # [ doc = " \\param callee fiber to start" ] # [ doc = " \\param ...    arguments to start the fiber with" ] # [ doc = "" ] # [ doc = " \\sa fiber_new" ] pub fn fiber_start ( callee : * mut fiber , ... ) ; } extern "C" { # [ doc = " Interrupt a synchronous wait of a fiber" ] # [ doc = "" ] # [ doc = " \\param f fiber to be woken up" ] pub fn fiber_wakeup ( f : * mut fiber ) ; } extern "C" { # [ doc = " Cancel the subject fiber. (set FIBER_IS_CANCELLED flag)" ] # [ doc = "" ] # [ doc = " If target fiber\'s flag FIBER_IS_CANCELLABLE set, then it would" ] # [ doc = " be woken up (maybe prematurely). Then current fiber yields" ] # [ doc = " until the target fiber is dead (or is woken up by" ] # [ doc = " \\sa fiber_wakeup)." ] # [ doc = "" ] # [ doc = " \\param f fiber to be cancelled" ] pub fn fiber_cancel ( f : * mut fiber ) ; } extern "C" { # [ doc = " Make it possible or not possible to wakeup the current" ] # [ doc = " fiber immediately when it\'s cancelled." ] # [ doc = "" ] # [ doc = " @param yesno status to set" ] # [ doc = " @return previous state." ] pub fn fiber_set_cancellable ( yesno : bool ) -> bool ; } extern "C" { # [ doc = " Set fiber to be joinable (false by default)." ] # [ doc = " \\param yesno status to set" ] pub fn fiber_set_joinable ( fiber : * mut fiber , yesno : bool ) ; } extern "C" { # [ doc = " Wait until the fiber is dead and then move its execution" ] # [ doc = " status to the caller." ] # [ doc = " The fiber must not be detached (@sa fiber_set_joinable())." ] # [ doc = " @pre FIBER_IS_JOINABLE flag is set." ] # [ doc = "" ] # [ doc = " \\param f fiber to be woken up" ] # [ doc = " \\return fiber function ret code" ] pub fn fiber_join ( f : * mut fiber ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Put the current fiber to sleep for at least \'s\' seconds." ] # [ doc = "" ] # [ doc = " \\param s time to sleep" ] # [ doc = "" ] # [ doc = " \\note this is a cancellation point (\\sa fiber_is_cancelled)" ] pub fn fiber_sleep ( s : f64 ) ; } extern "C" { # [ doc = " Check current fiber for cancellation (it must be checked" ] # [ doc = " manually)." ] pub fn fiber_is_cancelled ( ) -> bool ; } extern "C" { # [ doc = " Report loop begin time as double (cheap)." ] # [ doc = " Uses real time clock." ] pub fn fiber_time ( ) -> f64 ; } extern "C" { # [ doc = " Report loop begin time as 64-bit int." ] # [ doc = " Uses real time clock." ] pub fn fiber_time64 ( ) -> u64 ; } extern "C" { # [ doc = " Report loop begin time as double (cheap)." ] # [ doc = " Uses monotonic clock." ] pub fn fiber_clock ( ) -> f64 ; } extern "C" { # [ doc = " Report loop begin time as 64-bit int." ] # [ doc = " Uses monotonic clock." ] pub fn fiber_clock64 ( ) -> u64 ; } extern "C" { # [ doc = " Reschedule fiber to end of event loop cycle." ] pub fn fiber_reschedule ( ) ; } # [ doc = " Return slab_cache suitable to use with tarantool/small library" ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct slab_cache { _unused : [ u8 ; 0 ] , } extern "C" { pub fn cord_slab_cache ( ) -> * mut slab_cache ; } # [ doc = " Conditional variable for cooperative multitasking (fibers)." ] # [ doc = "" ] # [ doc = " A cond (short for \"condition variable\") is a synchronization primitive" ] # [ doc = " that allow fibers to yield until some predicate is satisfied. Fiber" ] # [ doc = " conditions have two basic operations - wait() and signal(). wait()" ] # [ doc = " suspends execution of fiber (i.e. yields) until signal() is called." ] # [ doc = " Unlike pthread_cond, fiber_cond doesn\'t require mutex/latch wrapping." ] # [ doc = "" ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct fiber_cond { _unused : [ u8 ; 0 ] , } extern "C" { # [ doc = " Instantiate a new fiber cond object." ] pub fn fiber_cond_new ( ) -> * mut fiber_cond ; } extern "C" { # [ doc = " Delete the fiber cond object." ] # [ doc = " Behaviour is undefined if there are fiber waiting for the cond." ] pub fn fiber_cond_delete ( cond : * mut fiber_cond ) ; } extern "C" { # [ doc = " Wake one fiber waiting for the cond." ] # [ doc = " Does nothing if no one is waiting." ] # [ doc = " @param cond condition" ] pub fn fiber_cond_signal ( cond : * mut fiber_cond ) ; } extern "C" { # [ doc = " Wake up all fibers waiting for the cond." ] # [ doc = " @param cond condition" ] pub fn fiber_cond_broadcast ( cond : * mut fiber_cond ) ; } extern "C" { # [ doc = " Suspend the execution of the current fiber (i.e. yield) until" ] # [ doc = " fiber_cond_signal() is called. Like pthread_cond, fiber_cond can issue" ] # [ doc = " spurious wake ups caused by explicit fiber_wakeup() or fiber_cancel()" ] # [ doc = " calls. It is highly recommended to wrap calls to this function into a loop" ] # [ doc = " and check an actual predicate and fiber_testcancel() on every iteration." ] # [ doc = "" ] # [ doc = " @param cond condition" ] # [ doc = " @param timeout timeout in seconds" ] # [ doc = " @retval 0 on fiber_cond_signal() call or a spurious wake up" ] # [ doc = " @retval -1 on timeout, diag is set to TimedOut" ] pub fn fiber_cond_wait_timeout ( cond : * mut fiber_cond , timeout : f64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Shortcut for fiber_cond_wait_timeout()." ] # [ doc = " @see fiber_cond_wait_timeout()" ] pub fn fiber_cond_wait ( cond : * mut fiber_cond ) -> :: std :: os :: raw :: c_int ; } # [ doc = " READ event" ] pub const COIO_READ : _bindgen_ty_1 = 1 ; # [ doc = " WRITE event" ] pub const COIO_WRITE : _bindgen_ty_1 = 2 ; # [ doc = " \\endcond public */" ] pub type _bindgen_ty_1 = u32 ; extern "C" { # [ doc = " Wait until READ or WRITE event on socket (\\a fd). Yields." ] # [ doc = " \\param fd - non-blocking socket file description" ] # [ doc = " \\param events - requested events to wait." ] # [ doc = " Combination of TNT_IO_READ | TNT_IO_WRITE bit flags." ] # [ doc = " \\param timeoout - timeout in seconds." ] # [ doc = " \\retval 0 - timeout" ] # [ doc = " \\retval >0 - returned events. Combination of TNT_IO_READ | TNT_IO_WRITE" ] # [ doc = " bit flags." ] pub fn coio_wait ( fd : :: std :: os :: raw :: c_int , event : :: std :: os :: raw :: c_int , timeout : f64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Close the fd and wake any fiber blocked in" ] # [ doc = " coio_wait() call on this fd." ] pub fn coio_close ( fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Create new eio task with specified function and" ] # [ doc = " arguments. Yield and wait until the task is complete" ] # [ doc = " or a timeout occurs." ] # [ doc = "" ] # [ doc = " This function doesn\'t throw exceptions to avoid double error" ] # [ doc = " checking: in most cases it\'s also necessary to check the return" ] # [ doc = " value of the called function and perform necessary actions. If" ] # [ doc = " func sets errno, the errno is preserved across the call." ] # [ doc = "" ] # [ doc = " @retval -1 and errno = ENOMEM if failed to create a task" ] # [ doc = " @retval the function return (errno is preserved)." ] # [ doc = "" ] # [ doc = " @code" ] # [ doc = "\tstatic ssize_t openfile_cb(va_list ap)" ] # [ doc = "\t{" ] # [ doc = "\t         const char *filename = va_arg(ap);" ] # [ doc = "\t         int flags = va_arg(ap);" ] # [ doc = "\t         return open(filename, flags);" ] # [ doc = "\t}" ] # [ doc = "" ] # [ doc = "\tif (coio_call(openfile_cb, 0.10, \"/tmp/file\", 0) == -1)" ] # [ doc = "\t\t// handle errors." ] # [ doc = "\t..." ] # [ doc = " @endcode" ] pub fn coio_call ( func : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut __va_list_tag ) -> isize > , ... ) -> isize ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct addrinfo { _unused : [ u8 ; 0 ] , } extern "C" { # [ doc = " Fiber-friendly version of getaddrinfo(3)." ] # [ doc = "" ] # [ doc = " @param host host name, i.e. \"tarantool.org\"" ] # [ doc = " @param port service name, i.e. \"80\" or \"http\"" ] # [ doc = " @param hints hints, see getaddrinfo(3)" ] # [ doc = " @param res[out] result, see getaddrinfo(3)" ] # [ doc = " @param timeout timeout" ] # [ doc = " @retval  0 on success, please free @a res using freeaddrinfo(3)." ] # [ doc = " @retval -1 on error, check diag." ] # [ doc = "            Please note that the return value is not compatible with" ] # [ doc = "            getaddrinfo(3)." ] # [ doc = " @sa getaddrinfo()" ] pub fn coio_getaddrinfo ( host : * const :: std :: os :: raw :: c_char , port : * const :: std :: os :: raw :: c_char , hints : * const addrinfo , res : * mut * mut addrinfo , timeout : f64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " @brief Push cdata of given \\a ctypeid onto the stack." ] # [ doc = " CTypeID must be used from FFI at least once. Allocated memory returned" ] # [ doc = " uninitialized. Only numbers and pointers are supported." ] # [ doc = " @param L Lua State" ] # [ doc = " @param ctypeid FFI\'s CTypeID of this cdata" ] # [ doc = " @sa luaL_checkcdata" ] # [ doc = " @return memory associated with this cdata" ] pub fn luaL_pushcdata ( L : * mut lua_State , ctypeid : u32 ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = " @brief Checks whether the function argument idx is a cdata" ] # [ doc = " @param L Lua State" ] # [ doc = " @param idx stack index" ] # [ doc = " @param ctypeid FFI\'s CTypeID of this cdata" ] # [ doc = " @sa luaL_pushcdata" ] # [ doc = " @return memory associated with this cdata" ] pub fn luaL_checkcdata ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int , ctypeid : * mut u32 ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = " @brief Sets finalizer function on a cdata object." ] # [ doc = " Equivalent to call ffi.gc(obj, function)." ] # [ doc = " Finalizer function must be on the top of the stack." ] # [ doc = " @param L Lua State" ] # [ doc = " @param idx object" ] pub fn luaL_setcdatagc ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " @brief Return CTypeID (FFI) of given \u{421}DATA type" ] # [ doc = " @param L Lua State" ] # [ doc = " @param ctypename \u{421} type name as string (e.g. \"struct request\" or \"uint32_t\")" ] # [ doc = " @sa luaL_pushcdata" ] # [ doc = " @sa luaL_checkcdata" ] # [ doc = " @return CTypeID" ] pub fn luaL_ctypeid ( L : * mut lua_State , ctypename : * const :: std :: os :: raw :: c_char ) -> u32 ; } extern "C" { # [ doc = " @brief Declare symbols for FFI" ] # [ doc = " @param L Lua State" ] # [ doc = " @param ctypename C definitions, e.g \"struct stat\"" ] # [ doc = " @sa ffi.cdef(def)" ] # [ doc = " @retval 0 on success" ] # [ doc = " @retval LUA_ERRRUN, LUA_ERRMEM, LUA_ERRERR otherwise" ] pub fn luaL_cdef ( L : * mut lua_State , ctypename : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Push uint64_t onto the stack" ] # [ doc = "" ] # [ doc = " @param L is a Lua State" ] # [ doc = " @param val is a value to push" ] pub fn luaL_pushuint64 ( L : * mut lua_State , val : u64 ) ; } extern "C" { # [ doc = " Push int64_t onto the stack" ] # [ doc = "" ] # [ doc = " @param L is a Lua State" ] # [ doc = " @param val is a value to push" ] pub fn luaL_pushint64 ( L : * mut lua_State , val : i64 ) ; } extern "C" { # [ doc = " Checks whether the argument idx is a uint64 or a convertable string and" ] # [ doc = " returns this number." ] # [ doc = " \\throws error if the argument can\'t be converted." ] pub fn luaL_checkuint64 ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> u64 ; } extern "C" { # [ doc = " Checks whether the argument idx is a int64 or a convertable string and" ] # [ doc = " returns this number." ] # [ doc = " \\throws error if the argument can\'t be converted." ] pub fn luaL_checkint64 ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> i64 ; } extern "C" { # [ doc = " Checks whether the argument idx is a uint64 or a convertable string and" ] # [ doc = " returns this number." ] # [ doc = " \\return the converted number or 0 of argument can\'t be converted." ] pub fn luaL_touint64 ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> u64 ; } extern "C" { # [ doc = " Checks whether the argument idx is a int64 or a convertable string and" ] # [ doc = " returns this number." ] # [ doc = " \\return the converted number or 0 of argument can\'t be converted." ] pub fn luaL_toint64 ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> i64 ; } extern "C" { # [ doc = " Re-throws the last Tarantool error as a Lua object." ] # [ doc = " \\sa lua_error()" ] # [ doc = " \\sa box_error_last()" ] pub fn luaT_error ( L : * mut lua_State ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Like lua_call(), but with the proper support of Tarantool errors." ] # [ doc = " \\sa lua_call()" ] pub fn luaT_call ( L : * mut lua_State , nargs : :: std :: os :: raw :: c_int , nreturns : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Like lua_cpcall(), but with the proper support of Tarantool errors." ] # [ doc = " \\sa lua_cpcall()" ] pub fn luaT_cpcall ( L : * mut lua_State , func : lua_CFunction , ud : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Get global Lua state used by Tarantool" ] pub fn luaT_state ( ) -> * mut lua_State ; } extern "C" { # [ doc = " Like lua_tolstring, but supports metatables, booleans and nil properly." ] pub fn luaT_tolstring ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int , ssize : * mut usize ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ doc = " Transaction id - a non-persistent unique identifier" ] # [ doc = " of the current transaction. -1 if there is no current" ] # [ doc = " transaction." ] pub fn box_txn_id ( ) -> i64 ; } extern "C" { # [ doc = " Return true if there is an active transaction." ] pub fn box_txn ( ) -> bool ; } extern "C" { # [ doc = " Begin a transaction in the current fiber." ] # [ doc = "" ] # [ doc = " A transaction is attached to caller fiber, therefore one fiber can have" ] # [ doc = " only one active transaction." ] # [ doc = "" ] # [ doc = " @retval 0 - success" ] # [ doc = " @retval -1 - failed, perhaps a transaction has already been" ] # [ doc = " started" ] pub fn box_txn_begin ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Commit the current transaction." ] # [ doc = " @retval 0 - success" ] # [ doc = " @retval -1 - failed, perhaps a disk write failure." ] # [ doc = " started" ] pub fn box_txn_commit ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Rollback the current transaction." ] # [ doc = " May fail if called from a nested" ] # [ doc = " statement." ] pub fn box_txn_rollback ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Allocate memory on txn memory pool." ] # [ doc = " The memory is automatically deallocated when the transaction" ] # [ doc = " is committed or rolled back." ] # [ doc = "" ] # [ doc = " @retval NULL out of memory" ] pub fn box_txn_alloc ( size : usize ) -> * mut :: std :: os :: raw :: c_void ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct key_def { _unused : [ u8 ; 0 ] , } # [ doc = " \\endcond public */" ] pub type box_key_def_t = key_def ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct tuple { _unused : [ u8 ; 0 ] , } # [ doc = " \\endcond public */" ] pub type box_tuple_t = tuple ; extern "C" { # [ doc = " Create key definition with key fields with passed typed on passed positions." ] # [ doc = " May be used for tuple format creation and/or tuple comparison." ] # [ doc = "" ] # [ doc = " \\param fields array with key field identifiers" ] # [ doc = " \\param types array with key field types (see enum field_type)" ] # [ doc = " \\param part_count the number of key fields" ] # [ doc = " \\returns a new key definition object" ] pub fn box_key_def_new ( fields : * mut u32 , types : * mut u32 , part_count : u32 ) -> * mut box_key_def_t ; } extern "C" { # [ doc = " Delete key definition" ] # [ doc = "" ] # [ doc = " \\param key_def key definition to delete" ] pub fn box_key_def_delete ( key_def : * mut box_key_def_t ) ; } extern "C" { # [ doc = " Compare tuples using the key definition." ] # [ doc = " @param tuple_a first tuple" ] # [ doc = " @param tuple_b second tuple" ] # [ doc = " @param key_def key definition" ] # [ doc = " @retval 0  if key_fields(tuple_a) == key_fields(tuple_b)" ] # [ doc = " @retval <0 if key_fields(tuple_a) < key_fields(tuple_b)" ] # [ doc = " @retval >0 if key_fields(tuple_a) > key_fields(tuple_b)" ] pub fn box_tuple_compare ( tuple_a : * const box_tuple_t , tuple_b : * const box_tuple_t , key_def : * mut box_key_def_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " @brief Compare tuple with key using the key definition." ] # [ doc = " @param tuple tuple" ] # [ doc = " @param key key with MessagePack array header" ] # [ doc = " @param key_def key definition" ] # [ doc = "" ] # [ doc = " @retval 0  if key_fields(tuple) == parts(key)" ] # [ doc = " @retval <0 if key_fields(tuple) < parts(key)" ] # [ doc = " @retval >0 if key_fields(tuple) > parts(key)" ] pub fn box_tuple_compare_with_key ( tuple_a : * const box_tuple_t , key_b : * const :: std :: os :: raw :: c_char , key_def : * mut box_key_def_t ) -> :: std :: os :: raw :: c_int ; } pub const field_type_FIELD_TYPE_ANY : field_type = 0 ; pub const field_type_FIELD_TYPE_UNSIGNED : field_type = 1 ; pub const field_type_FIELD_TYPE_STRING : field_type = 2 ; pub const field_type_FIELD_TYPE_NUMBER : field_type = 3 ; pub const field_type_FIELD_TYPE_INTEGER : field_type = 4 ; pub const field_type_FIELD_TYPE_BOOLEAN : field_type = 5 ; pub const field_type_FIELD_TYPE_SCALAR : field_type = 6 ; pub const field_type_FIELD_TYPE_ARRAY : field_type = 7 ; pub const field_type_FIELD_TYPE_MAP : field_type = 8 ; pub const field_type_field_type_MAX : field_type = 9 ; # [ doc = " \\endcond public */" ] pub type field_type = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct tuple_format { _unused : [ u8 ; 0 ] , } # [ doc = " \\endcond public */" ] pub type box_tuple_format_t = tuple_format ; extern "C" { # [ doc = " Tuple Format." ] # [ doc = "" ] # [ doc = " Each Tuple has associated format (class). Default format is used to" ] # [ doc = " create tuples which are not attach to any particular space." ] pub fn box_tuple_format_default ( ) -> * mut box_tuple_format_t ; } extern "C" { # [ doc = " Increase the reference counter of tuple." ] # [ doc = "" ] # [ doc = " Tuples are reference counted. All functions that return tuples guarantee" ] # [ doc = " that the last returned tuple is refcounted internally until the next" ] # [ doc = " call to API function that yields or returns another tuple." ] # [ doc = "" ] # [ doc = " You should increase the reference counter before taking tuples for long" ] # [ doc = " processing in your code. Such tuples will not be garbage collected even" ] # [ doc = " if another fiber remove they from space. After processing please" ] # [ doc = " decrement the reference counter using box_tuple_unref(), otherwise the" ] # [ doc = " tuple will leak." ] # [ doc = "" ] # [ doc = " \\param tuple a tuple" ] # [ doc = " \\retval 0 always" ] # [ doc = " \\sa box_tuple_unref()" ] pub fn box_tuple_ref ( tuple : * mut box_tuple_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Decrease the reference counter of tuple." ] # [ doc = "" ] # [ doc = " \\param tuple a tuple" ] # [ doc = " \\sa box_tuple_ref()" ] pub fn box_tuple_unref ( tuple : * mut box_tuple_t ) ; } extern "C" { # [ doc = " Return the number of fields in tuple (the size of MsgPack Array)." ] # [ doc = " \\param tuple a tuple" ] pub fn box_tuple_field_count ( tuple : * const box_tuple_t ) -> u32 ; } extern "C" { # [ doc = " Return the number of bytes used to store internal tuple data (MsgPack Array)." ] # [ doc = " \\param tuple a tuple" ] pub fn box_tuple_bsize ( tuple : * const box_tuple_t ) -> usize ; } extern "C" { # [ doc = " Dump raw MsgPack data to the memory byffer \\a buf of size \\a size." ] # [ doc = "" ] # [ doc = " Store tuple fields in the memory buffer." ] # [ doc = " \\retval -1 on error." ] # [ doc = " \\retval number of bytes written on success." ] # [ doc = " Upon successful return, the function returns the number of bytes written." ] # [ doc = " If buffer size is not enough then the return value is the number of bytes" ] # [ doc = " which would have been written if enough space had been available." ] pub fn box_tuple_to_buf ( tuple : * const box_tuple_t , buf : * mut :: std :: os :: raw :: c_char , size : usize ) -> isize ; } extern "C" { # [ doc = " Return the associated format." ] # [ doc = " \\param tuple tuple" ] # [ doc = " \\return tuple_format" ] pub fn box_tuple_format ( tuple : * const box_tuple_t ) -> * mut box_tuple_format_t ; } extern "C" { # [ doc = " Return the raw tuple field in MsgPack format." ] # [ doc = "" ] # [ doc = " The buffer is valid until next call to box_tuple_* functions." ] # [ doc = "" ] # [ doc = " \\param tuple a tuple" ] # [ doc = " \\param fieldno zero-based index in MsgPack array." ] # [ doc = " \\retval NULL if i >= box_tuple_field_count(tuple)" ] # [ doc = " \\retval msgpack otherwise" ] pub fn box_tuple_field ( tuple : * const box_tuple_t , fieldno : u32 ) -> * const :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct tuple_iterator { _unused : [ u8 ; 0 ] , } # [ doc = " Tuple iterator" ] pub type box_tuple_iterator_t = tuple_iterator ; extern "C" { # [ doc = " Allocate and initialize a new tuple iterator. The tuple iterator" ] # [ doc = " allow to iterate over fields at root level of MsgPack array." ] # [ doc = "" ] # [ doc = " Example:" ] # [ doc = " \\code" ] # [ doc = " box_tuple_iterator *it = box_tuple_iterator(tuple);" ] # [ doc = " if (it == NULL) {" ] # [ doc = "      // error handling using box_error_last()" ] # [ doc = " }" ] # [ doc = " const char *field;" ] # [ doc = " while (field = box_tuple_next(it)) {" ] # [ doc = "      // process raw MsgPack data" ] # [ doc = " }" ] # [ doc = "" ] # [ doc = " // rewind iterator to first position" ] # [ doc = " box_tuple_rewind(it);" ] # [ doc = " assert(box_tuple_position(it) == 0);" ] # [ doc = "" ] # [ doc = " // rewind iterator to first position" ] # [ doc = " field = box_tuple_seek(it, 3);" ] # [ doc = " assert(box_tuple_position(it) == 4);" ] # [ doc = "" ] # [ doc = " box_iterator_free(it);" ] # [ doc = " \\endcode" ] # [ doc = "" ] # [ doc = " \\post box_tuple_position(it) == 0" ] pub fn box_tuple_iterator ( tuple : * mut box_tuple_t ) -> * mut box_tuple_iterator_t ; } extern "C" { # [ doc = " Destroy and free tuple iterator" ] pub fn box_tuple_iterator_free ( it : * mut box_tuple_iterator_t ) ; } extern "C" { # [ doc = " Return zero-based next position in iterator." ] # [ doc = " That is, this function return the field id of field that will be" ] # [ doc = " returned by the next call to box_tuple_next(it). Returned value is zero" ] # [ doc = " after initialization or rewind and box_tuple_field_count(tuple)" ] # [ doc = " after the end of iteration." ] # [ doc = "" ] # [ doc = " \\param it tuple iterator" ] # [ doc = " \\returns position." ] pub fn box_tuple_position ( it : * mut box_tuple_iterator_t ) -> u32 ; } extern "C" { # [ doc = " Rewind iterator to the initial position." ] # [ doc = "" ] # [ doc = " \\param it tuple iterator" ] # [ doc = " \\post box_tuple_position(it) == 0" ] pub fn box_tuple_rewind ( it : * mut box_tuple_iterator_t ) ; } extern "C" { # [ doc = " Seek the tuple iterator." ] # [ doc = "" ] # [ doc = " The returned buffer is valid until next call to box_tuple_* API." ] # [ doc = " Requested fieldno returned by next call to box_tuple_next(it)." ] # [ doc = "" ] # [ doc = " \\param it tuple iterator" ] # [ doc = " \\param fieldno - zero-based position in MsgPack array." ] # [ doc = " \\post box_tuple_position(it) == fieldno if returned value is not NULL" ] # [ doc = " \\post box_tuple_position(it) == box_tuple_field_count(tuple) if returned" ] # [ doc = " value is NULL." ] pub fn box_tuple_seek ( it : * mut box_tuple_iterator_t , fieldno : u32 ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ doc = " Return the next tuple field from tuple iterator." ] # [ doc = " The returned buffer is valid until next call to box_tuple_* API." ] # [ doc = "" ] # [ doc = " \\param it tuple iterator." ] # [ doc = " \\retval NULL if there are no more fields." ] # [ doc = " \\retval MsgPack otherwise" ] # [ doc = " \\pre box_tuple_position(it) is zerod-based id of returned field" ] # [ doc = " \\post box_tuple_position(it) == box_tuple_field_count(tuple) if returned" ] # [ doc = " value is NULL." ] pub fn box_tuple_next ( it : * mut box_tuple_iterator_t ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ doc = " Allocate and initialize a new tuple from a raw MsgPack Array data." ] # [ doc = "" ] # [ doc = " \\param format tuple format." ] # [ doc = " Use box_tuple_format_default() to create space-independent tuple." ] # [ doc = " \\param data tuple data in MsgPack Array format ([field1, field2, ...])." ] # [ doc = " \\param end the end of \\a data" ] # [ doc = " \\retval tuple" ] # [ doc = " \\pre data, end is valid MsgPack Array" ] # [ doc = " \\sa \\code box.tuple.new(data) \\endcode" ] pub fn box_tuple_new ( format : * mut box_tuple_format_t , data : * const :: std :: os :: raw :: c_char , end : * const :: std :: os :: raw :: c_char ) -> * mut box_tuple_t ; } extern "C" { pub fn box_tuple_update ( tuple : * const box_tuple_t , expr : * const :: std :: os :: raw :: c_char , expr_end : * const :: std :: os :: raw :: c_char ) -> * mut box_tuple_t ; } extern "C" { pub fn box_tuple_upsert ( tuple : * const box_tuple_t , expr : * const :: std :: os :: raw :: c_char , expr_end : * const :: std :: os :: raw :: c_char ) -> * mut box_tuple_t ; } extern "C" { # [ doc = " Return new in-memory tuple format based on passed key definitions." ] # [ doc = "" ] # [ doc = " \\param keys array of keys defined for the format" ] # [ doc = " \\key_count count of keys" ] # [ doc = " \\retval new tuple format if success" ] # [ doc = " \\retval NULL for error" ] pub fn box_tuple_format_new ( keys : * mut * mut key_def , key_count : u16 ) -> * mut box_tuple_format_t ; } extern "C" { # [ doc = " Increment tuple format ref count." ] # [ doc = "" ] # [ doc = " \\param tuple_format the tuple format to ref" ] pub fn box_tuple_format_ref ( format : * mut box_tuple_format_t ) ; } extern "C" { # [ doc = " Decrement tuple format ref count." ] # [ doc = "" ] # [ doc = " \\param tuple_format the tuple format to unref" ] pub fn box_tuple_format_unref ( format : * mut box_tuple_format_t ) ; } # [ doc = " Start of the reserved range of system spaces." ] pub const BOX_SYSTEM_ID_MIN : _bindgen_ty_2 = 256 ; # [ doc = " Space if of _vinyl_deferred_delete." ] pub const BOX_VINYL_DEFERRED_DELETE_ID : _bindgen_ty_2 = 257 ; # [ doc = " Space id of _schema." ] pub const BOX_SCHEMA_ID : _bindgen_ty_2 = 272 ; # [ doc = " Space id of _collation." ] pub const BOX_COLLATION_ID : _bindgen_ty_2 = 276 ; # [ doc = " Space id of _space." ] pub const BOX_SPACE_ID : _bindgen_ty_2 = 280 ; # [ doc = " Space id of _vspace view." ] pub const BOX_VSPACE_ID : _bindgen_ty_2 = 281 ; # [ doc = " Space id of _sequence." ] pub const BOX_SEQUENCE_ID : _bindgen_ty_2 = 284 ; # [ doc = " Space id of _sequence_data." ] pub const BOX_SEQUENCE_DATA_ID : _bindgen_ty_2 = 285 ; # [ doc = " Space id of _vsequence view." ] pub const BOX_VSEQUENCE_ID : _bindgen_ty_2 = 286 ; # [ doc = " Space id of _index." ] pub const BOX_INDEX_ID : _bindgen_ty_2 = 288 ; # [ doc = " Space id of _vindex view." ] pub const BOX_VINDEX_ID : _bindgen_ty_2 = 289 ; # [ doc = " Space id of _func." ] pub const BOX_FUNC_ID : _bindgen_ty_2 = 296 ; # [ doc = " Space id of _vfunc view." ] pub const BOX_VFUNC_ID : _bindgen_ty_2 = 297 ; # [ doc = " Space id of _user." ] pub const BOX_USER_ID : _bindgen_ty_2 = 304 ; # [ doc = " Space id of _vuser view." ] pub const BOX_VUSER_ID : _bindgen_ty_2 = 305 ; # [ doc = " Space id of _priv." ] pub const BOX_PRIV_ID : _bindgen_ty_2 = 312 ; # [ doc = " Space id of _vpriv view." ] pub const BOX_VPRIV_ID : _bindgen_ty_2 = 313 ; # [ doc = " Space id of _cluster." ] pub const BOX_CLUSTER_ID : _bindgen_ty_2 = 320 ; # [ doc = " Space id of _truncate." ] pub const BOX_TRUNCATE_ID : _bindgen_ty_2 = 330 ; # [ doc = " Space id of _space_sequence." ] pub const BOX_SPACE_SEQUENCE_ID : _bindgen_ty_2 = 340 ; # [ doc = " End of the reserved range of system spaces." ] pub const BOX_SYSTEM_ID_MAX : _bindgen_ty_2 = 511 ; # [ doc = " End of the reserved range of system spaces." ] pub const BOX_ID_NIL : _bindgen_ty_2 = 2147483647 ; # [ doc = " \\endcond public */" ] pub type _bindgen_ty_2 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct box_function_ctx { _unused : [ u8 ; 0 ] , } # [ doc = " \\endcond public */" ] pub type box_function_ctx_t = box_function_ctx ; extern "C" { # [ doc = " Return a tuple from stored C procedure." ] # [ doc = "" ] # [ doc = " Returned tuple is automatically reference counted by Tarantool." ] # [ doc = "" ] # [ doc = " \\param ctx an opaque structure passed to the stored C procedure by" ] # [ doc = " Tarantool" ] # [ doc = " \\param tuple a tuple to return" ] # [ doc = " \\retval -1 on error (perhaps, out of memory; check box_error_last())" ] # [ doc = " \\retval 0 otherwise" ] pub fn box_return_tuple ( ctx : * mut box_function_ctx_t , tuple : * mut box_tuple_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Find space id by name." ] # [ doc = "" ] # [ doc = " This function performs SELECT request to _vspace system space." ] # [ doc = " \\param name space name" ] # [ doc = " \\param len length of \\a name" ] # [ doc = " \\retval BOX_ID_NIL on error or if not found (check box_error_last())" ] # [ doc = " \\retval space_id otherwise" ] # [ doc = " \\sa box_index_id_by_name" ] pub fn box_space_id_by_name ( name : * const :: std :: os :: raw :: c_char , len : u32 ) -> u32 ; } extern "C" { # [ doc = " Find index id by name." ] # [ doc = "" ] # [ doc = " This function performs SELECT request to _vindex system space." ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param name index name" ] # [ doc = " \\param len length of \\a name" ] # [ doc = " \\retval BOX_ID_NIL on error or if not found (check box_error_last())" ] # [ doc = " \\retval index_id otherwise" ] # [ doc = " \\sa box_space_id_by_name" ] pub fn box_index_id_by_name ( space_id : u32 , name : * const :: std :: os :: raw :: c_char , len : u32 ) -> u32 ; } extern "C" { # [ doc = " Execute an INSERT request." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param tuple encoded tuple in MsgPack Array format ([ field1, field2, ...])" ] # [ doc = " \\param tuple_end end of @a tuple" ] # [ doc = " \\param[out] result a new tuple. Can be set to NULL to discard result." ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval 0 on success" ] # [ doc = " \\sa \\code box.space[space_id]:insert(tuple) \\endcode" ] pub fn box_insert ( space_id : u32 , tuple : * const :: std :: os :: raw :: c_char , tuple_end : * const :: std :: os :: raw :: c_char , result : * mut * mut box_tuple_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Execute an REPLACE request." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param tuple encoded tuple in MsgPack Array format ([ field1, field2, ...])" ] # [ doc = " \\param tuple_end end of @a tuple" ] # [ doc = " \\param[out] result a new tuple. Can be set to NULL to discard result." ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval 0 on success" ] # [ doc = " \\sa \\code box.space[space_id]:replace(tuple) \\endcode" ] pub fn box_replace ( space_id : u32 , tuple : * const :: std :: os :: raw :: c_char , tuple_end : * const :: std :: os :: raw :: c_char , result : * mut * mut box_tuple_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Execute an DELETE request." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param index_id index identifier" ] # [ doc = " \\param key encoded key in MsgPack Array format ([part1, part2, ...])." ] # [ doc = " \\param key_end the end of encoded \\a key." ] # [ doc = " \\param[out] result an old tuple. Can be set to NULL to discard result." ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval 0 on success" ] # [ doc = " \\sa \\code box.space[space_id].index[index_id]:delete(key) \\endcode" ] pub fn box_delete ( space_id : u32 , index_id : u32 , key : * const :: std :: os :: raw :: c_char , key_end : * const :: std :: os :: raw :: c_char , result : * mut * mut box_tuple_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Execute an UPDATE request." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param index_id index identifier" ] # [ doc = " \\param key encoded key in MsgPack Array format ([part1, part2, ...])." ] # [ doc = " \\param key_end the end of encoded \\a key." ] # [ doc = " \\param ops encoded operations in MsgPack Arrat format, e.g." ] # [ doc = " [ [ \'=\', fieldno,  value ],  [\'!\', 2, \'xxx\'] ]" ] # [ doc = " \\param ops_end the end of encoded \\a ops" ] # [ doc = " \\param index_base 0 if fieldnos in update operations are zero-based" ] # [ doc = " indexed (like C) or 1 if for one-based indexed field ids (like Lua)." ] # [ doc = " \\param[out] result a new tuple. Can be set to NULL to discard result." ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval 0 on success" ] # [ doc = " \\sa \\code box.space[space_id].index[index_id]:update(key, ops) \\endcode" ] # [ doc = " \\sa box_upsert()" ] pub fn box_update ( space_id : u32 , index_id : u32 , key : * const :: std :: os :: raw :: c_char , key_end : * const :: std :: os :: raw :: c_char , ops : * const :: std :: os :: raw :: c_char , ops_end : * const :: std :: os :: raw :: c_char , index_base : :: std :: os :: raw :: c_int , result : * mut * mut box_tuple_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Execute an UPSERT request." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param index_id index identifier" ] # [ doc = " \\param ops encoded operations in MsgPack Arrat format, e.g." ] # [ doc = " [ [ \'=\', fieldno,  value ],  [\'!\', 2, \'xxx\'] ]" ] # [ doc = " \\param ops_end the end of encoded \\a ops" ] # [ doc = " \\param tuple encoded tuple in MsgPack Array format ([ field1, field2, ...])" ] # [ doc = " \\param tuple_end end of @a tuple" ] # [ doc = " \\param index_base 0 if fieldnos in update operations are zero-based" ] # [ doc = " indexed (like C) or 1 if for one-based indexed field ids (like Lua)." ] # [ doc = " \\param[out] result a new tuple. Can be set to NULL to discard result." ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval 0 on success" ] # [ doc = " \\sa \\code box.space[space_id].index[index_id]:update(key, ops) \\endcode" ] # [ doc = " \\sa box_update()" ] pub fn box_upsert ( space_id : u32 , index_id : u32 , tuple : * const :: std :: os :: raw :: c_char , tuple_end : * const :: std :: os :: raw :: c_char , ops : * const :: std :: os :: raw :: c_char , ops_end : * const :: std :: os :: raw :: c_char , index_base : :: std :: os :: raw :: c_int , result : * mut * mut box_tuple_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Truncate space." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] pub fn box_truncate ( space_id : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Advance a sequence." ] # [ doc = "" ] # [ doc = " \\param seq_id sequence identifier" ] # [ doc = " \\param[out] result pointer to a variable where the next sequence" ] # [ doc = " value will be stored on success" ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval 0 on success" ] pub fn box_sequence_next ( seq_id : u32 , result : * mut i64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Set a sequence value." ] # [ doc = "" ] # [ doc = " \\param seq_id sequence identifier" ] # [ doc = " \\param value new sequence value; on success the next call to" ] # [ doc = " box_sequence_next() will return the value following \\a value" ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval 0 on success" ] pub fn box_sequence_set ( seq_id : u32 , value : i64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Reset a sequence." ] # [ doc = "" ] # [ doc = " \\param seq_id sequence identifier" ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval 0 on success" ] pub fn box_sequence_reset ( seq_id : u32 ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct iterator { _unused : [ u8 ; 0 ] , } pub type box_iterator_t = iterator ; extern "C" { # [ doc = " Allocate and initialize iterator for space_id, index_id." ] # [ doc = "" ] # [ doc = " A returned iterator must be destroyed by box_iterator_free()." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier." ] # [ doc = " \\param index_id index identifier." ] # [ doc = " \\param type \\link iterator_type iterator type \\endlink" ] # [ doc = " \\param key encoded key in MsgPack Array format ([part1, part2, ...])." ] # [ doc = " \\param key_end the end of encoded \\a key" ] # [ doc = " \\retval NULL on error (check box_error_last())" ] # [ doc = " \\retval iterator otherwise" ] # [ doc = " \\sa box_iterator_next()" ] # [ doc = " \\sa box_iterator_free()" ] pub fn box_index_iterator ( space_id : u32 , index_id : u32 , type_ : :: std :: os :: raw :: c_int , key : * const :: std :: os :: raw :: c_char , key_end : * const :: std :: os :: raw :: c_char ) -> * mut box_iterator_t ; } extern "C" { # [ doc = " Retrive the next item from the \\a iterator." ] # [ doc = "" ] # [ doc = " \\param iterator an iterator returned by box_index_iterator()." ] # [ doc = " \\param[out] result a tuple or NULL if there is no more data." ] # [ doc = " \\retval -1 on error (check box_error_last() for details)" ] # [ doc = " \\retval 0 on success. The end of data is not an error." ] pub fn box_iterator_next ( iterator : * mut box_iterator_t , result : * mut * mut box_tuple_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Destroy and deallocate iterator." ] # [ doc = "" ] # [ doc = " \\param iterator an interator returned by box_index_iterator()" ] pub fn box_iterator_free ( iterator : * mut box_iterator_t ) ; } extern "C" { # [ doc = " Return the number of element in the index." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param index_id index identifier" ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval >= 0 otherwise" ] pub fn box_index_len ( space_id : u32 , index_id : u32 ) -> isize ; } extern "C" { # [ doc = " Return the number of bytes used in memory by the index." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param index_id index identifier" ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval >= 0 otherwise" ] pub fn box_index_bsize ( space_id : u32 , index_id : u32 ) -> isize ; } extern "C" { # [ doc = " Return a random tuple from the index (useful for statistical analysis)." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param index_id index identifier" ] # [ doc = " \\param rnd random seed" ] # [ doc = " \\param[out] result a tuple or NULL if index is empty" ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval 0 on success" ] # [ doc = " \\sa \\code box.space[space_id].index[index_id]:random(rnd) \\endcode" ] pub fn box_index_random ( space_id : u32 , index_id : u32 , rnd : u32 , result : * mut * mut box_tuple_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Get a tuple from index by the key." ] # [ doc = "" ] # [ doc = " Please note that this function works much more faster than" ] # [ doc = " box_select() or box_index_iterator() + box_iterator_next()." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param index_id index identifier" ] # [ doc = " \\param key encoded key in MsgPack Array format ([part1, part2, ...])." ] # [ doc = " \\param key_end the end of encoded \\a key" ] # [ doc = " \\param[out] result a tuple or NULL if index is empty" ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval 0 on success" ] # [ doc = " \\pre key != NULL" ] # [ doc = " \\sa \\code box.space[space_id].index[index_id]:get(key) \\endcode" ] pub fn box_index_get ( space_id : u32 , index_id : u32 , key : * const :: std :: os :: raw :: c_char , key_end : * const :: std :: os :: raw :: c_char , result : * mut * mut box_tuple_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Return a first (minimal) tuple matched the provided key." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param index_id index identifier" ] # [ doc = " \\param key encoded key in MsgPack Array format ([part1, part2, ...])." ] # [ doc = " \\param key_end the end of encoded \\a key." ] # [ doc = " \\param[out] result a tuple or NULL if index is empty" ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval 0 on success" ] # [ doc = " \\sa \\code box.space[space_id].index[index_id]:min(key) \\endcode" ] pub fn box_index_min ( space_id : u32 , index_id : u32 , key : * const :: std :: os :: raw :: c_char , key_end : * const :: std :: os :: raw :: c_char , result : * mut * mut box_tuple_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Return a last (maximal) tuple matched the provided key." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param index_id index identifier" ] # [ doc = " \\param key encoded key in MsgPack Array format ([part1, part2, ...])." ] # [ doc = " \\param key_end the end of encoded \\a key." ] # [ doc = " \\param[out] result a tuple or NULL if index is empty" ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval 0 on success" ] # [ doc = " \\sa \\code box.space[space_id].index[index_id]:max(key) \\endcode" ] pub fn box_index_max ( space_id : u32 , index_id : u32 , key : * const :: std :: os :: raw :: c_char , key_end : * const :: std :: os :: raw :: c_char , result : * mut * mut box_tuple_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Count the number of tuple matched the provided key." ] # [ doc = "" ] # [ doc = " \\param space_id space identifier" ] # [ doc = " \\param index_id index identifier" ] # [ doc = " \\param type iterator type - enum \\link iterator_type \\endlink" ] # [ doc = " \\param key encoded key in MsgPack Array format ([part1, part2, ...])." ] # [ doc = " \\param key_end the end of encoded \\a key." ] # [ doc = " \\retval -1 on error (check box_error_last())" ] # [ doc = " \\retval >=0 on success" ] # [ doc = " \\sa \\code box.space[space_id].index[index_id]:count(key," ] # [ doc = "     { iterator = type }) \\endcode" ] pub fn box_index_count ( space_id : u32 , index_id : u32 , type_ : :: std :: os :: raw :: c_int , key : * const :: std :: os :: raw :: c_char , key_end : * const :: std :: os :: raw :: c_char ) -> isize ; } extern "C" { # [ doc = " Extract key from tuple according to key definition of given" ] # [ doc = " index. Returned buffer is allocated on box_txn_alloc() with" ] # [ doc = " this key." ] # [ doc = " @param tuple Tuple from which need to extract key." ] # [ doc = " @param space_id Space identifier." ] # [ doc = " @param index_id Index identifier." ] # [ doc = " @retval not NULL Success" ] # [ doc = " @retval     NULL Memory Allocation error" ] pub fn box_tuple_extract_key ( tuple : * const box_tuple_t , space_id : u32 , index_id : u32 , key_size : * mut u32 ) -> * mut :: std :: os :: raw :: c_char ; } pub const iterator_type_ITER_EQ : iterator_type = 0 ; pub const iterator_type_ITER_REQ : iterator_type = 1 ; pub const iterator_type_ITER_ALL : iterator_type = 2 ; pub const iterator_type_ITER_LT : iterator_type = 3 ; pub const iterator_type_ITER_LE : iterator_type = 4 ; pub const iterator_type_ITER_GE : iterator_type = 5 ; pub const iterator_type_ITER_GT : iterator_type = 6 ; pub const iterator_type_ITER_BITS_ALL_SET : iterator_type = 7 ; pub const iterator_type_ITER_BITS_ANY_SET : iterator_type = 8 ; pub const iterator_type_ITER_BITS_ALL_NOT_SET : iterator_type = 9 ; pub const iterator_type_ITER_OVERLAPS : iterator_type = 10 ; pub const iterator_type_ITER_NEIGHBOR : iterator_type = 11 ; pub const iterator_type_iterator_type_MAX : iterator_type = 12 ; # [ doc = " Controls how to iterate over tuples in an index." ] # [ doc = " Different index types support different iterator types." ] # [ doc = " For example, one can start iteration from a particular value" ] # [ doc = " (request key) and then retrieve all tuples where keys are" ] # [ doc = " greater or equal (= GE) to this key." ] # [ doc = "" ] # [ doc = " If iterator type is not supported by the selected index type," ] # [ doc = " iterator constructor must fail with ER_UNSUPPORTED. To be" ] # [ doc = " selectable for primary key, an index must support at least" ] # [ doc = " ITER_EQ and ITER_GE types." ] # [ doc = "" ] # [ doc = " NULL value of request key corresponds to the first or last" ] # [ doc = " key in the index, depending on iteration direction." ] # [ doc = " (first key for GE and GT types, and last key for LE and LT)." ] # [ doc = " Therefore, to iterate over all tuples in an index, one can" ] # [ doc = " use ITER_GE or ITER_LE iteration types with start key equal" ] # [ doc = " to NULL." ] # [ doc = " For ITER_EQ, the key must not be NULL." ] pub type iterator_type = u32 ; # [ doc = " \\endcond public */" ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct error { _unused : [ u8 ; 0 ] , } # [ doc = " Error - contains information about error." ] pub type box_error_t = error ; extern "C" { # [ doc = " Return the error type, e.g. \"ClientError\", \"SocketError\", etc." ] # [ doc = " \\param error" ] # [ doc = " \\return not-null string" ] pub fn box_error_type ( error : * const box_error_t ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ doc = " Return IPROTO error code" ] # [ doc = " \\param error error" ] # [ doc = " \\return enum box_error_code" ] pub fn box_error_code ( error : * const box_error_t ) -> u32 ; } extern "C" { # [ doc = " Return the error message" ] # [ doc = " \\param error error" ] # [ doc = " \\return not-null string" ] pub fn box_error_message ( error : * const box_error_t ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ doc = " Get the information about the last API call error." ] # [ doc = "" ] # [ doc = " The Tarantool error handling works most like libc\'s errno. All API calls" ] # [ doc = " return -1 or NULL in the event of error. An internal pointer to" ] # [ doc = " box_error_t type is set by API functions to indicate what went wrong." ] # [ doc = " This value is only significant if API call failed (returned -1 or NULL)." ] # [ doc = "" ] # [ doc = " Successful function can also touch the last error in some" ] # [ doc = " cases. You don\'t have to clear the last error before calling" ] # [ doc = " API functions. The returned object is valid only until next" ] # [ doc = " call to **any** API function." ] # [ doc = "" ] # [ doc = " You must set the last error using box_error_set() in your stored C" ] # [ doc = " procedures if you want to return a custom error message." ] # [ doc = " You can re-throw the last API error to IPROTO client by keeping" ] # [ doc = " the current value and returning -1 to Tarantool from your" ] # [ doc = " stored procedure." ] # [ doc = "" ] # [ doc = " \\return last error." ] pub fn box_error_last ( ) -> * mut box_error_t ; } extern "C" { # [ doc = " Clear the last error." ] pub fn box_error_clear ( ) ; } extern "C" { # [ doc = " Set the last error." ] # [ doc = "" ] # [ doc = " \\param code IPROTO error code (enum \\link box_error_code \\endlink)" ] # [ doc = " \\param format (const char * ) - printf()-like format string" ] # [ doc = " \\param ... - format arguments" ] # [ doc = " \\returns -1 for convention use" ] # [ doc = "" ] # [ doc = " \\sa enum box_error_code" ] pub fn box_error_set ( file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_uint , code : u32 , format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Push a tuple onto the stack." ] # [ doc = " @param L Lua State" ] # [ doc = " @sa luaT_istuple" ] # [ doc = " @throws on OOM" ] pub fn luaT_pushtuple ( L : * mut lua_State , tuple : * mut box_tuple_t ) ; } extern "C" { # [ doc = " Checks whether argument idx is a tuple" ] # [ doc = "" ] # [ doc = " @param L Lua State" ] # [ doc = " @param idx the stack index" ] # [ doc = " @retval non-NULL argument is tuple" ] # [ doc = " @retval NULL argument is not tuple" ] pub fn luaT_istuple ( L : * mut lua_State , idx : :: std :: os :: raw :: c_int ) -> * mut box_tuple_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct box_latch { _unused : [ u8 ; 0 ] , } # [ doc = " A lock for cooperative multitasking environment" ] pub type box_latch_t = box_latch ; extern "C" { # [ doc = " Allocate and initialize the new latch." ] # [ doc = " \\returns latch" ] pub fn box_latch_new ( ) -> * mut box_latch_t ; } extern "C" { # [ doc = " Destroy and free the latch." ] # [ doc = " \\param latch latch" ] pub fn box_latch_delete ( latch : * mut box_latch_t ) ; } extern "C" { # [ doc = " Lock a latch. Waits indefinitely until the current fiber can gain access to" ] # [ doc = " the latch." ] # [ doc = "" ] # [ doc = " \\param latch a latch" ] pub fn box_latch_lock ( latch : * mut box_latch_t ) ; } extern "C" { # [ doc = " Try to lock a latch. Return immediately if the latch is locked." ] # [ doc = " \\param latch a latch" ] # [ doc = " \\retval 0 - success" ] # [ doc = " \\retval 1 - the latch is locked." ] pub fn box_latch_trylock ( latch : * mut box_latch_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Unlock a latch. The fiber calling this function must" ] # [ doc = " own the latch." ] # [ doc = "" ] # [ doc = " \\param latch a latch" ] pub fn box_latch_unlock ( latch : * mut box_latch_t ) ; } extern "C" { # [ doc = " \\endcond public */" ] pub fn clock_realtime ( ) -> f64 ; } extern "C" { pub fn clock_monotonic ( ) -> f64 ; } extern "C" { pub fn clock_process ( ) -> f64 ; } extern "C" { pub fn clock_thread ( ) -> f64 ; } extern "C" { pub fn clock_realtime64 ( ) -> u64 ; } extern "C" { pub fn clock_monotonic64 ( ) -> u64 ; } extern "C" { pub fn clock_process64 ( ) -> u64 ; } extern "C" { pub fn clock_thread64 ( ) -> u64 ; } pub const box_error_code_ER_UNKNOWN : box_error_code = 0 ; pub const box_error_code_ER_ILLEGAL_PARAMS : box_error_code = 1 ; pub const box_error_code_ER_MEMORY_ISSUE : box_error_code = 2 ; pub const box_error_code_ER_TUPLE_FOUND : box_error_code = 3 ; pub const box_error_code_ER_TUPLE_NOT_FOUND : box_error_code = 4 ; pub const box_error_code_ER_UNSUPPORTED : box_error_code = 5 ; pub const box_error_code_ER_NONMASTER : box_error_code = 6 ; pub const box_error_code_ER_READONLY : box_error_code = 7 ; pub const box_error_code_ER_INJECTION : box_error_code = 8 ; pub const box_error_code_ER_CREATE_SPACE : box_error_code = 9 ; pub const box_error_code_ER_SPACE_EXISTS : box_error_code = 10 ; pub const box_error_code_ER_DROP_SPACE : box_error_code = 11 ; pub const box_error_code_ER_ALTER_SPACE : box_error_code = 12 ; pub const box_error_code_ER_INDEX_TYPE : box_error_code = 13 ; pub const box_error_code_ER_MODIFY_INDEX : box_error_code = 14 ; pub const box_error_code_ER_LAST_DROP : box_error_code = 15 ; pub const box_error_code_ER_TUPLE_FORMAT_LIMIT : box_error_code = 16 ; pub const box_error_code_ER_DROP_PRIMARY_KEY : box_error_code = 17 ; pub const box_error_code_ER_KEY_PART_TYPE : box_error_code = 18 ; pub const box_error_code_ER_EXACT_MATCH : box_error_code = 19 ; pub const box_error_code_ER_INVALID_MSGPACK : box_error_code = 20 ; pub const box_error_code_ER_PROC_RET : box_error_code = 21 ; pub const box_error_code_ER_TUPLE_NOT_ARRAY : box_error_code = 22 ; pub const box_error_code_ER_FIELD_TYPE : box_error_code = 23 ; pub const box_error_code_ER_INDEX_PART_TYPE_MISMATCH : box_error_code = 24 ; pub const box_error_code_ER_SPLICE : box_error_code = 25 ; pub const box_error_code_ER_UPDATE_ARG_TYPE : box_error_code = 26 ; pub const box_error_code_ER_FORMAT_MISMATCH_INDEX_PART : box_error_code = 27 ; pub const box_error_code_ER_UNKNOWN_UPDATE_OP : box_error_code = 28 ; pub const box_error_code_ER_UPDATE_FIELD : box_error_code = 29 ; pub const box_error_code_ER_FUNCTION_TX_ACTIVE : box_error_code = 30 ; pub const box_error_code_ER_KEY_PART_COUNT : box_error_code = 31 ; pub const box_error_code_ER_PROC_LUA : box_error_code = 32 ; pub const box_error_code_ER_NO_SUCH_PROC : box_error_code = 33 ; pub const box_error_code_ER_NO_SUCH_TRIGGER : box_error_code = 34 ; pub const box_error_code_ER_NO_SUCH_INDEX : box_error_code = 35 ; pub const box_error_code_ER_NO_SUCH_SPACE : box_error_code = 36 ; pub const box_error_code_ER_NO_SUCH_FIELD : box_error_code = 37 ; pub const box_error_code_ER_EXACT_FIELD_COUNT : box_error_code = 38 ; pub const box_error_code_ER_MIN_FIELD_COUNT : box_error_code = 39 ; pub const box_error_code_ER_WAL_IO : box_error_code = 40 ; pub const box_error_code_ER_MORE_THAN_ONE_TUPLE : box_error_code = 41 ; pub const box_error_code_ER_ACCESS_DENIED : box_error_code = 42 ; pub const box_error_code_ER_CREATE_USER : box_error_code = 43 ; pub const box_error_code_ER_DROP_USER : box_error_code = 44 ; pub const box_error_code_ER_NO_SUCH_USER : box_error_code = 45 ; pub const box_error_code_ER_USER_EXISTS : box_error_code = 46 ; pub const box_error_code_ER_PASSWORD_MISMATCH : box_error_code = 47 ; pub const box_error_code_ER_UNKNOWN_REQUEST_TYPE : box_error_code = 48 ; pub const box_error_code_ER_UNKNOWN_SCHEMA_OBJECT : box_error_code = 49 ; pub const box_error_code_ER_CREATE_FUNCTION : box_error_code = 50 ; pub const box_error_code_ER_NO_SUCH_FUNCTION : box_error_code = 51 ; pub const box_error_code_ER_FUNCTION_EXISTS : box_error_code = 52 ; pub const box_error_code_ER_BEFORE_REPLACE_RET : box_error_code = 53 ; pub const box_error_code_ER_FUNCTION_MAX : box_error_code = 54 ; pub const box_error_code_ER_UNUSED4 : box_error_code = 55 ; pub const box_error_code_ER_USER_MAX : box_error_code = 56 ; pub const box_error_code_ER_NO_SUCH_ENGINE : box_error_code = 57 ; pub const box_error_code_ER_RELOAD_CFG : box_error_code = 58 ; pub const box_error_code_ER_CFG : box_error_code = 59 ; pub const box_error_code_ER_SAVEPOINT_EMPTY_TX : box_error_code = 60 ; pub const box_error_code_ER_NO_SUCH_SAVEPOINT : box_error_code = 61 ; pub const box_error_code_ER_UNKNOWN_REPLICA : box_error_code = 62 ; pub const box_error_code_ER_REPLICASET_UUID_MISMATCH : box_error_code = 63 ; pub const box_error_code_ER_INVALID_UUID : box_error_code = 64 ; pub const box_error_code_ER_REPLICASET_UUID_IS_RO : box_error_code = 65 ; pub const box_error_code_ER_INSTANCE_UUID_MISMATCH : box_error_code = 66 ; pub const box_error_code_ER_REPLICA_ID_IS_RESERVED : box_error_code = 67 ; pub const box_error_code_ER_INVALID_ORDER : box_error_code = 68 ; pub const box_error_code_ER_MISSING_REQUEST_FIELD : box_error_code = 69 ; pub const box_error_code_ER_IDENTIFIER : box_error_code = 70 ; pub const box_error_code_ER_DROP_FUNCTION : box_error_code = 71 ; pub const box_error_code_ER_ITERATOR_TYPE : box_error_code = 72 ; pub const box_error_code_ER_REPLICA_MAX : box_error_code = 73 ; pub const box_error_code_ER_INVALID_XLOG : box_error_code = 74 ; pub const box_error_code_ER_INVALID_XLOG_NAME : box_error_code = 75 ; pub const box_error_code_ER_INVALID_XLOG_ORDER : box_error_code = 76 ; pub const box_error_code_ER_NO_CONNECTION : box_error_code = 77 ; pub const box_error_code_ER_TIMEOUT : box_error_code = 78 ; pub const box_error_code_ER_ACTIVE_TRANSACTION : box_error_code = 79 ; pub const box_error_code_ER_CURSOR_NO_TRANSACTION : box_error_code = 80 ; pub const box_error_code_ER_CROSS_ENGINE_TRANSACTION : box_error_code = 81 ; pub const box_error_code_ER_NO_SUCH_ROLE : box_error_code = 82 ; pub const box_error_code_ER_ROLE_EXISTS : box_error_code = 83 ; pub const box_error_code_ER_CREATE_ROLE : box_error_code = 84 ; pub const box_error_code_ER_INDEX_EXISTS : box_error_code = 85 ; pub const box_error_code_ER_SESSION_CLOSED : box_error_code = 86 ; pub const box_error_code_ER_ROLE_LOOP : box_error_code = 87 ; pub const box_error_code_ER_GRANT : box_error_code = 88 ; pub const box_error_code_ER_PRIV_GRANTED : box_error_code = 89 ; pub const box_error_code_ER_ROLE_GRANTED : box_error_code = 90 ; pub const box_error_code_ER_PRIV_NOT_GRANTED : box_error_code = 91 ; pub const box_error_code_ER_ROLE_NOT_GRANTED : box_error_code = 92 ; pub const box_error_code_ER_MISSING_SNAPSHOT : box_error_code = 93 ; pub const box_error_code_ER_CANT_UPDATE_PRIMARY_KEY : box_error_code = 94 ; pub const box_error_code_ER_UPDATE_INTEGER_OVERFLOW : box_error_code = 95 ; pub const box_error_code_ER_GUEST_USER_PASSWORD : box_error_code = 96 ; pub const box_error_code_ER_TRANSACTION_CONFLICT : box_error_code = 97 ; pub const box_error_code_ER_UNSUPPORTED_PRIV : box_error_code = 98 ; pub const box_error_code_ER_LOAD_FUNCTION : box_error_code = 99 ; pub const box_error_code_ER_FUNCTION_LANGUAGE : box_error_code = 100 ; pub const box_error_code_ER_RTREE_RECT : box_error_code = 101 ; pub const box_error_code_ER_PROC_C : box_error_code = 102 ; pub const box_error_code_ER_UNKNOWN_RTREE_INDEX_DISTANCE_TYPE : box_error_code = 103 ; pub const box_error_code_ER_PROTOCOL : box_error_code = 104 ; pub const box_error_code_ER_UPSERT_UNIQUE_SECONDARY_KEY : box_error_code = 105 ; pub const box_error_code_ER_WRONG_INDEX_RECORD : box_error_code = 106 ; pub const box_error_code_ER_WRONG_INDEX_PARTS : box_error_code = 107 ; pub const box_error_code_ER_WRONG_INDEX_OPTIONS : box_error_code = 108 ; pub const box_error_code_ER_WRONG_SCHEMA_VERSION : box_error_code = 109 ; pub const box_error_code_ER_MEMTX_MAX_TUPLE_SIZE : box_error_code = 110 ; pub const box_error_code_ER_WRONG_SPACE_OPTIONS : box_error_code = 111 ; pub const box_error_code_ER_UNSUPPORTED_INDEX_FEATURE : box_error_code = 112 ; pub const box_error_code_ER_VIEW_IS_RO : box_error_code = 113 ; pub const box_error_code_ER_SAVEPOINT_NO_TRANSACTION : box_error_code = 114 ; pub const box_error_code_ER_SYSTEM : box_error_code = 115 ; pub const box_error_code_ER_LOADING : box_error_code = 116 ; pub const box_error_code_ER_CONNECTION_TO_SELF : box_error_code = 117 ; pub const box_error_code_ER_KEY_PART_IS_TOO_LONG : box_error_code = 118 ; pub const box_error_code_ER_COMPRESSION : box_error_code = 119 ; pub const box_error_code_ER_CHECKPOINT_IN_PROGRESS : box_error_code = 120 ; pub const box_error_code_ER_SUB_STMT_MAX : box_error_code = 121 ; pub const box_error_code_ER_COMMIT_IN_SUB_STMT : box_error_code = 122 ; pub const box_error_code_ER_ROLLBACK_IN_SUB_STMT : box_error_code = 123 ; pub const box_error_code_ER_DECOMPRESSION : box_error_code = 124 ; pub const box_error_code_ER_INVALID_XLOG_TYPE : box_error_code = 125 ; pub const box_error_code_ER_ALREADY_RUNNING : box_error_code = 126 ; pub const box_error_code_ER_INDEX_FIELD_COUNT_LIMIT : box_error_code = 127 ; pub const box_error_code_ER_LOCAL_INSTANCE_ID_IS_READ_ONLY : box_error_code = 128 ; pub const box_error_code_ER_BACKUP_IN_PROGRESS : box_error_code = 129 ; pub const box_error_code_ER_READ_VIEW_ABORTED : box_error_code = 130 ; pub const box_error_code_ER_INVALID_INDEX_FILE : box_error_code = 131 ; pub const box_error_code_ER_INVALID_RUN_FILE : box_error_code = 132 ; pub const box_error_code_ER_INVALID_VYLOG_FILE : box_error_code = 133 ; pub const box_error_code_ER_CHECKPOINT_ROLLBACK : box_error_code = 134 ; pub const box_error_code_ER_VY_QUOTA_TIMEOUT : box_error_code = 135 ; pub const box_error_code_ER_PARTIAL_KEY : box_error_code = 136 ; pub const box_error_code_ER_TRUNCATE_SYSTEM_SPACE : box_error_code = 137 ; pub const box_error_code_ER_LOAD_MODULE : box_error_code = 138 ; pub const box_error_code_ER_VINYL_MAX_TUPLE_SIZE : box_error_code = 139 ; pub const box_error_code_ER_WRONG_DD_VERSION : box_error_code = 140 ; pub const box_error_code_ER_WRONG_SPACE_FORMAT : box_error_code = 141 ; pub const box_error_code_ER_CREATE_SEQUENCE : box_error_code = 142 ; pub const box_error_code_ER_ALTER_SEQUENCE : box_error_code = 143 ; pub const box_error_code_ER_DROP_SEQUENCE : box_error_code = 144 ; pub const box_error_code_ER_NO_SUCH_SEQUENCE : box_error_code = 145 ; pub const box_error_code_ER_SEQUENCE_EXISTS : box_error_code = 146 ; pub const box_error_code_ER_SEQUENCE_OVERFLOW : box_error_code = 147 ; pub const box_error_code_ER_UNUSED5 : box_error_code = 148 ; pub const box_error_code_ER_SPACE_FIELD_IS_DUPLICATE : box_error_code = 149 ; pub const box_error_code_ER_CANT_CREATE_COLLATION : box_error_code = 150 ; pub const box_error_code_ER_WRONG_COLLATION_OPTIONS : box_error_code = 151 ; pub const box_error_code_ER_NULLABLE_PRIMARY : box_error_code = 152 ; pub const box_error_code_ER_UNUSED : box_error_code = 153 ; pub const box_error_code_ER_TRANSACTION_YIELD : box_error_code = 154 ; pub const box_error_code_ER_NO_SUCH_GROUP : box_error_code = 155 ; pub const box_error_code_box_error_code_MAX : box_error_code = 156 ; # [ doc = " \\endcond public" ] pub type box_error_code = u32 ; pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . gp_offset as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . fp_offset as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . overflow_arg_area as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . reg_save_area as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_data { pub _address : u8 , }